<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Maven 导入依赖失败</title>
    <link href="/2021/10/24/Maven-%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96%E5%A4%B1%E8%B4%A5/"/>
    <url>/2021/10/24/Maven-%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96%E5%A4%B1%E8%B4%A5/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><p>问题详情：导入依赖时，出现无法解析依赖，或者找不到该依赖的问题。</p><p>问题分析：依赖部分的代码全是从 <a href="https://mvnrepository.com/">mvnrepository.com</a> 网站上直接复制的，不可能出现错误。然后想到了之前学校安排的生产实习课上老师说过导入依赖时，如果出现问题了，可以看下本地仓库里面对应的目录下是否有 .lastupdated 后缀的文件，如果有就删掉它们，然后再次更新 pom.xml 文件。</p><p>导致出现这样的问题的原因：Maven 在尝试下载 jar 包的时候出现了问题，导致下载失败。为了节省宽带，在一定时间内不会再次尝试下载该文件。</p><p>解决方案：</p><ol><li><p>手动删除本地仓库中 .lastupdated 后缀的文件。</p><p> Windows：直接使用文件资源管理器访问本地仓库目录，然后搜索 .lastupdated，在得到的结果中，手动删除后缀为 .lastupdated 的文件。</p><p> Linux ：使用以下命令删除：</p> <figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 方式一</span><br>find ~/.m2 -name *.lastUpdated -delete<br><span class="hljs-comment"># 方式二</span><br><span class="hljs-built_in">rm</span> ~/.m2/repository/**/*.lastUpdated<br><span class="hljs-comment"># 方式三</span><br>find -name \*.lastUpdated -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">rm</span> -fv &#123;&#125; +<br></code></pre></td></tr></table></figure></li><li><p>在 maven 命令之后，加上 -U。<strong>这种方式我没使用过</strong>，不过据说相对于手动删除 .lastupdated 后缀的文件要好，毕竟手动删除可能会删错文件。</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn -U clean<br></code></pre></td></tr></table></figure></li></ol><p>参考链接：</p><ol><li><a href="https://stackoverflow.com/a/4556024">https://stackoverflow.com/a/4556024</a></li><li><a href="https://stackoverflow.com/a/13149707">https://stackoverflow.com/a/13149707</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC 学习笔记</title>
    <link href="/2021/10/14/SpringMVC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/14/SpringMVC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><h3 id="页面跳转方式"><a href="#页面跳转方式" class="headerlink" title="页面跳转方式"></a>页面跳转方式</h3><ol><li>当 ControllerTest 类实现 Controller 接口时，通过 ModelAndView 对象的 setViewName 方法设置视图名称，然后返回 ModelAndView 对象。</li><li>（<strong>常用</strong>）当 ControllerTest 类使用了 @Controller 注解时，通过一个返回值为 String 的方法，返回视图名称。</li></ol><p>以上两种方式都是通过视图解析器进行页面跳转的。</p><p>还有就是可以通过 return 返回值时，返回不同字符串，达到重定向和转发的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/t3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ControllerTest3</span> &#123;<br>    <span class="hljs-comment">// 转发</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/test1&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/WEB-INF/jsp/test.jsp&quot;</span>;<br>    &#125;<br><span class="hljs-comment">// 转发</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/test2&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/WEB-INF/jsp/test.jsp&quot;</span>;<br>    &#125;<br><span class="hljs-comment">// 重定向</span><br>    <span class="hljs-comment">// 这里会无法访问，因为 WEB-INF 目录下的东西浏览器无法直接访问到</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/test3&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/WEB-INF/jsp/test.jsp&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外，还可以通过 ServletAPI 进行页面跳转（req 是 HttpServletRequest 类的对象，resp 是 HttpServletResponse 类的对象） ：</p><ol><li>通过 <code>req.getRequestDispatcher(&quot;/xxx/xxx.jsp&quot;).forward(req,resp)</code> 进行转发。</li><li>通过 <code>resp.sendRedirect(&quot;xxx.jsp&quot;)</code> 进行重定向。</li><li>通过 <code>resp.getWriter().println(&quot;This is test!!!&quot;)</code> 进行输出。</li></ol><h3 id="重定向和转发的区别"><a href="#重定向和转发的区别" class="headerlink" title="重定向和转发的区别"></a>重定向和转发的区别</h3><blockquote><p>参考链接：<a href="https://javarevisited.blogspot.com/2011/09/sendredirect-forward-jsp-servlet.html">https://javarevisited.blogspot.com/2011/09/sendredirect-forward-jsp-servlet.html</a></p></blockquote><table><thead><tr><th>转发</th><th>重定向</th></tr></thead><tbody><tr><td>当使用转发操作时，一般是转发到同一个服务器的资源</td><td>重定向到的新的页面<strong>一般</strong>是不同服务器或域名上的资源</td></tr><tr><td>转发一般发生在服务器内部，客户端或浏览器无法察觉到这种操作</td><td>重定向一般发生在浏览器上</td></tr><tr><td>转发可以将旧的 request 和 response 对象发送到新的资源中</td><td>在重定向到新的页面后，旧的 request 和 response 对象会被丢失，因为浏览器会发送新的请求</td></tr><tr><td>在浏览器地址栏上不会显示新的 url</td><td>在浏览器地址栏上可以看到新的 url</td></tr><tr><td>（相同情况下）转发比重定向快，它只需要一次往返时间</td><td>（相同情况下）重定向更慢，因为浏览器需要创建一个新的请求，也就是需要两次往返时间</td></tr><tr><td>如果向在转发之前需要添加参数的话，可以通过 <code>request.setAttribute()</code> 方法来设置参数</td><td>如果在重定向之前需要添加必要的参数的话，可以将数据存储在 session 里面或 url 里面</td></tr></tbody></table><h3 id="Restful-风格"><a href="#Restful-风格" class="headerlink" title="Restful 风格"></a>Restful 风格</h3><p>使用方式：使用 @PathVariable 注解，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RestfulController</span> &#123;<br><br>    <span class="hljs-comment">// 原本访问的链接为：http://localhost:8080/add?a=1&amp;b=2</span><br>    <span class="hljs-comment">// Restful 风格访问链接（原来的方式就不行了）：http://localhost:8080/add/1/2</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test1</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> a, <span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> b, Model model)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> a + b;<br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;结果为&quot;</span>+ res);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><h4 id="1-找不到-DispatcherServlet-类"><a href="#1-找不到-DispatcherServlet-类" class="headerlink" title="1. 找不到 DispatcherServlet 类"></a>1. 找不到 DispatcherServlet 类</h4><p>报错信息：</p><blockquote><p> HTTP状态 500 - 内部服务器错误</p><p><strong>类型</strong> 异常报告</p><p><strong>消息</strong> 实例化Servlet类[org.springframework.web.servlet.DispatcherServlet]异常</p><p><strong>描述</strong> 服务器遇到一个意外的情况，阻止它完成请求。</p><p><strong>根本原因</strong></p><p>java.lang.ClassNotFoundException: org.springframework.web.servlet.DispatcherServlet</p></blockquote><p>报错信息分析：报错信息很明显，找不到 <code>DispatcherServlet</code> 类，说明<strong>有可能</strong>是生成的文件找不到 jar 包。</p><p>解决方法：</p><ol><li><p>进入 Project Structure 设置页面，点击进入 Artifacts 页面，然后<strong>选中 WEB-INF 目录</strong>，点击创建目录。</p><p> <img src="https://i.loli.net/2021/10/14/9Y3tHRqELC1PxWc.png" alt="创建 lib 目录"></p></li><li><p>然后创建一个名为 lib 的目录，并<strong>选中 lib 目录</strong>，然后点击 <code>+</code>，然后选中 Library Files，添加所有的 jar 包。</p><p> <img src="https://i.loli.net/2021/10/14/yPX7mlx8ChUzDYk.png" alt="添加 jar 包"></p></li></ol><h4 id="2-无法打开-ServletContext-资源"><a href="#2-无法打开-ServletContext-资源" class="headerlink" title="2. 无法打开 ServletContext 资源"></a>2. 无法打开 ServletContext 资源</h4><p>报错信息：</p><blockquote><p><strong>类型</strong> 异常报告</p><p><strong>消息</strong> Servlet[springmvc]的Servlet.init（）引发异常</p><p><strong>描述</strong> 服务器遇到一个意外的情况，阻止它完成请求。</p><p><strong>根本原因</strong></p><p>java.io.FileNotFoundException: Could not open ServletContext resource [&#x2F;WEB-INF&#x2F;springmvc-servlet.xml]</p></blockquote><p>报错分析：我的代码是按照视频教程一步一步敲的，遇到这个问题可能是配置问题，于是直接选择 Google 搜索关键字：Could not open ServletContext resource，然后在 StackOverflow 上找到一个解决方案（<a href="https://stackoverflow.com/a/24531097">点击跳转链接</a>）。</p><p>解决方法：</p><ul><li><p>在 web.xml 文件中，servlet 标签下添加 init-param 标签，并设置 param-name 和 param-value。</p><p>  <img src="https://i.loli.net/2021/10/14/4YZxkuJC5rXPe3W.png" alt="添加红框部分代码"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis学习笔记</title>
    <link href="/2021/10/08/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/08/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><blockquote><p>学习方式：看B站视频（<a href="https://www.bilibili.com/video/BV1NE411Q7Nx?share_source=copy_web">链接</a>），边看边敲代码</p><p>注：该笔记不全，只是挑着记录</p></blockquote><h3 id="使用MyBatis步骤"><a href="#使用MyBatis步骤" class="headerlink" title="使用MyBatis步骤"></a>使用MyBatis步骤</h3><ol><li><p>导入Maven包</p></li><li><p>写<code>MyBatisUtils</code>工具类，用于创建<code>SqlSession</code>对象（代码可复用）</p> <figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisUtils</span> &#123;<br>    <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource)) &#123;<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>写<code>mybatis-config.xml</code>文件</p></li><li><p>写实体（<code>POJO</code>&#x2F;<code>Model</code>&#x2F;<code>entity</code>）类</p></li><li><p>写<code>Mapper</code>（<code>DAO</code>）接口</p></li><li><p>写<code>xxxMapper.xml</code>文件（对应<code>Mapper</code>&#x2F;<code>DAO</code>接口）</p></li><li><p>写测试类，测试<code>Mapper</code>&#x2F;<code>DAO</code>接口</p></li></ol><h3 id="MyBatis执行流程"><a href="#MyBatis执行流程" class="headerlink" title="MyBatis执行流程"></a>MyBatis执行流程</h3><ol><li>通过<code>Resources</code>类获取并加载全局配置文件。</li><li>实例化<code>SqlSessionFactoryBuilder</code>建造者对象。</li><li>解析配置文件流（<code>build</code>方法里面用到了<code>XMLConfigBuilder</code>）。</li><li>通过<code>XMLConfigBuilder</code>对象的<code>parse</code>方法获取<code>Configuration</code>对象。</li><li>通过<code>Configuration</code>对象和<code>DefaultSqlSessionFactory</code>获取<code>SqlSessionFactory</code>对象。</li><li>（待续。。。）</li></ol><h3 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h3><ol><li>注解直接在接口上实现sql语句</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(select * from user)</span><br><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUserList</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>需要在核心配置文件中绑定接口。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.rziyang.mapper.UserMapper&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以使用<code>@Param</code>注解指定参数名字。</p><h3 id="多对一处理"><a href="#多对一处理" class="headerlink" title="多对一处理"></a>多对一处理</h3><ol><li><p>按照查询嵌套处理（类似于子查询）：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.rziyang.mapper.StudentMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;StudentResultMap&quot;</span>&gt;</span><br>        select id,name,tid from mybatis_study.student;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>        select id,name from mybatis_study.teacher where id = #&#123;tid&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>按照结果嵌套处理（联表查询）：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.rziyang.mapper.StudentMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;StudentResultMap&quot;</span>&gt;</span><br>        select s.id sid,s.name sname,tid,t.name tname from mybatis_study.student s,mybatis_study.teacher t where s.tid = t.id<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="一对多处理"><a href="#一对多处理" class="headerlink" title="一对多处理"></a>一对多处理</h3><ol><li><p>按结果嵌套处理（注意：<code>collection</code>标签使用<code>ofType</code>标志泛型类型，而不是<code>type</code>）：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.rziyang.mapper.TeacherMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;TeacherResultMap&quot;</span>&gt;</span><br>        select t.id tid,t.name tname,s.id sid,s.name sname<br>        from mybatis_study.teacher t,mybatis_study.student s<br>        where t.id=s.tid and t.id=#&#123;tid&#125;;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;TeacherResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>按照子查询嵌套处理：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.rziyang.mapper.TeacherMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 方式二：按子查询的方式 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;TeacherResultMap&quot;</span>&gt;</span><br>        select id,name from mybatis_study.teacher where id = #&#123;tid&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;TeacherResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;ArrayList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getStudents&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudents&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>        select id,name from mybatis_study.student where tid = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><ol><li><p><code>if</code>标签（条件语句）</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>    SELECT * FROM BLOG WHERE state = ‘ACTIVE’<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>        AND title like #&#123;title&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>        AND author_name like #&#123;author.name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><code>choose</code>、<code>when</code>、<code>otherwise</code>标签（选择语句，类似于Java的switch）</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>    SELECT * FROM BLOG WHERE state = ‘ACTIVE’<br>    <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>            AND title like #&#123;title&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>            AND author_name like #&#123;author.name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>            AND featured = 1<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><code>trim</code>、<code>where</code>、<code>set</code>标签</p><p> <code>where</code>标签会自动在sql语句中添加<code>where</code>（如果所有<code>if</code>标签的条件都为假，则不添加<code>where</code>），并去掉紧跟在<code>where</code>标签后面的<code>or</code>和<code>and</code>。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>    SELECT * FROM BLOG<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;state != null&quot;</span>&gt;</span><br>            state = #&#123;state&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>            AND title like #&#123;title&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>            AND author_name like #&#123;author.name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p> <code>trim</code>标签则用于在sql语句中自定义添加内容，下面是用<code>trim</code>标签实现<code>where</code>标签的功能的语句（<code>prefixOverrides</code> 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 <code>prefixOverrides</code> 属性中指定的内容，并且插入 <code>prefix</code>属性中指定的内容。）：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;WHERE&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;AND |OR &quot;</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></table></figure><p> <code>set</code>标签用于在<code>update</code>语句中添加<code>set</code>部分，下面是示例代码（这个例子中，<code>set</code> 元素会动态地在行首插入 <code>SET</code> 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的））：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span><br>    update Author<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 使用<code>trim</code>标签实现<code>set</code>标签的功能的代码如下（注意，我们覆盖了后缀值设置，并且自定义了前缀值。）：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;SET&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><code>foreach</code>标签</p><p> <code>foreach</code>标签用于对集合进行遍历，示例代码如下：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPostIn&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;domain.blog.Post&quot;</span>&gt;</span><br>    SELECT *<br>    FROM POST P<br>    WHERE ID in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;item&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p> <em><code>foreach</code></em> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（<code>item</code>）和索引（<code>index</code>）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！</p><p> 提示：你可以将任何可迭代对象（如 <code>List</code>、<code>Set</code> 等）、<code>Map</code> 对象或者数组对象作为集合参数传递给 <code>foreach</code>。当使用可迭代对象或者数组时，<code>index</code> 是当前迭代的序号，<code>item</code> 的值是本次迭代获取到的元素。当使用 <code>Map</code> 对象（或者 <code>Map.Entry</code> 对象的集合）时，<code>index</code> 是键，<code>item</code> 是值。</p></li></ol><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ol><li><p>本地缓存（一级缓存）：默认开启，作用域是<code>SqlSession</code>，进行增删改操作会刷新缓存，也可调用<code>SqlSession</code>里面的方法手动刷新缓存。以下代码为本地缓存使用示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getBlogIf</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession())&#123;<br>        <span class="hljs-type">BlogMapper</span> <span class="hljs-variable">blogMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BlogMapper.class);<br>        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;title&quot;</span>,<span class="hljs-string">&quot;MyBatis test01&quot;</span>);<br>        List&lt;Blog&gt; blogList1 = blogMapper.getBlogIf(map);<br>        <span class="hljs-keyword">for</span> (Blog blog : blogList1) &#123;<br>            System.out.println(blog);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;====================&quot;</span>);<br>        List&lt;Blog&gt; blogList2 = blogMapper.getBlogIf(map);<br>        <span class="hljs-keyword">for</span> (Blog blog : blogList2) &#123;<br>            System.out.println(blog);<br>        &#125;<br>        System.out.println(blogList1 == blogList2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 日志显示：</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">DEBUG</span> LogFactory -<span class="hljs-built_in"> Logging </span>initialized using <span class="hljs-string">&#x27;class org.apache.ibatis.logging.log4j.Log4jImpl&#x27;</span> adapter.<span class="hljs-built_in"></span><br><span class="hljs-built_in">Logging </span>initialized using <span class="hljs-string">&#x27;class org.apache.ibatis.logging.stdout.StdOutImpl&#x27;</span> adapter.<br>PooledDataSource forcefully closed/removed all connections.<br>PooledDataSource forcefully closed/removed all connections.<br>PooledDataSource forcefully closed/removed all connections.<br>PooledDataSource forcefully closed/removed all connections.<br>Opening JDBC<span class="hljs-built_in"> Connection</span><br><span class="hljs-built_in"></span>Created<span class="hljs-built_in"> connection </span>623247230.<br>Setting autocommit <span class="hljs-keyword">to</span> <span class="hljs-literal">false</span> on JDBC<span class="hljs-built_in"> Connection </span>[com.mysql.cj.jdbc.ConnectionImpl@2525ff7e]<br>==&gt;  Preparing: select * <span class="hljs-keyword">from</span> mybatis_study.blog where <span class="hljs-attribute">1</span>=1 <span class="hljs-keyword">and</span> title = ?<br>==&gt; Parameters: MyBatis test01(String)<br>&lt;==    Columns: id, title, author, create_time, views<br>&lt;==        Row: 83578ba29a9248a89d5302f198acbad3, MyBatis test01, RZIYang, 2021-10-07 07:47:33, 111<br>&lt;==      Total: 1<br>Blog&#123;<span class="hljs-attribute">id</span>=<span class="hljs-string">&#x27;83578ba29a9248a89d5302f198acbad3&#x27;</span>, <span class="hljs-attribute">title</span>=<span class="hljs-string">&#x27;MyBatis test01&#x27;</span>, <span class="hljs-attribute">author</span>=<span class="hljs-string">&#x27;RZIYang&#x27;</span>, <span class="hljs-attribute">createTime</span>=Thu Oct 07 15:47:33 CST 2021, <span class="hljs-attribute">views</span>=111&#125;<br>====================<br>Blog&#123;<span class="hljs-attribute">id</span>=<span class="hljs-string">&#x27;83578ba29a9248a89d5302f198acbad3&#x27;</span>, <span class="hljs-attribute">title</span>=<span class="hljs-string">&#x27;MyBatis test01&#x27;</span>, <span class="hljs-attribute">author</span>=<span class="hljs-string">&#x27;RZIYang&#x27;</span>, <span class="hljs-attribute">createTime</span>=Thu Oct 07 15:47:33 CST 2021, <span class="hljs-attribute">views</span>=111&#125;<br><span class="hljs-literal">true</span><br>Resetting autocommit <span class="hljs-keyword">to</span> <span class="hljs-literal">true</span> on JDBC<span class="hljs-built_in"> Connection </span>[com.mysql.cj.jdbc.ConnectionImpl@2525ff7e]<br>Closing JDBC<span class="hljs-built_in"> Connection </span>[com.mysql.cj.jdbc.ConnectionImpl@2525ff7e]<br>Returned<span class="hljs-built_in"> connection </span>623247230 <span class="hljs-keyword">to</span> pool.<br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p> 由日志可以看出，只进行了一次sql查询。两个<code>List</code>变量指向同一个对象。</p></li><li><p>全局缓存（二级缓存）：</p><p> 使用全局缓存步骤：</p><ol><li><p>（<strong>非必要</strong>，默认为<code>true</code>，但是显式说明使用了全局缓存）在<code>mybatis-config.xml</code>文件中，添加一个<code>setting</code>标签：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在<code>xxxMapper.xml</code>文件中添加<code>&lt;cache/&gt;</code>标签。</p></li></ol><p> 注意：</p><ol><li>需要将对应的实体类序列化（实现序列化的接口）。</li><li>当一个<code>SqlSession</code>关闭（调用<code>close</code>方法）之后，它的本地缓存才会存入全局缓存中。</li><li>全局缓存针对单个mapper，如果mapper类不同，它们的全局缓存也不同。</li></ol></li></ol><h3 id="log4j使用步骤"><a href="#log4j使用步骤" class="headerlink" title="log4j使用步骤"></a>log4j使用步骤</h3><ol><li>导入log4j包</li><li>创建<code>log4j.properties</code>文件，并写入配置。<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#Define root logger options</span><br><span class="hljs-attr">log4j.rootLogger</span>=<span class="hljs-string">DEBUG, file, console</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#Define console appender</span><br><span class="hljs-attr">log4j.appender.console</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-attr">logrj.appender.console.Target</span>=<span class="hljs-string">System.out</span><br><span class="hljs-attr">log4j.appender.console.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-attr">log4j.appender.console.layout.ConversionPattern</span>=<span class="hljs-string">%-5p %c&#123;1&#125; - %m%n</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#Define rolling file appender</span><br><span class="hljs-attr">log4j.appender.file</span>=<span class="hljs-string">org.apache.log4j.RollingFileAppender</span><br><span class="hljs-attr">log4j.appender.file.File</span>=<span class="hljs-string">logs/main.log</span><br><span class="hljs-attr">log4j.appender.file.Append</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">log4j.appender.file.ImmediateFlush</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">log4j.appender.file.MaxFileSize</span>=<span class="hljs-string">10MB</span><br><span class="hljs-attr">log4j.appender.file.MaxBackupIndex</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">log4j.appender.file.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-attr">log4j.appender.file.layout.ConversionPattern</span>=<span class="hljs-string">%d %d&#123;Z&#125; [%t] %-5p (%F:%L) - %m%n</span><br></code></pre></td></tr></table></figure></li><li>在<code>mybatis-config.xml</code>文件中添加日志实现（设置<code>settings</code>标签里面的<code>setting</code>标签）<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>log4j的使用：使用Java代码记录日志<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperTest</span> &#123;<br>    <span class="hljs-comment">// 声明Logger对象</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(UserMapperTest.class);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLogger</span><span class="hljs-params">()</span>&#123;<br>        logger.info(<span class="hljs-string">&quot;testLogger():success&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="lombok使用步骤"><a href="#lombok使用步骤" class="headerlink" title="lombok使用步骤"></a>lombok使用步骤</h3><ol><li>在IDEA中下载<code>lombok</code>插件。</li><li>导入对应的包。</li><li>使用注解。</li></ol><h3 id="导入的包"><a href="#导入的包" class="headerlink" title="导入的包"></a>导入的包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- MyBatis包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- MySQL容器包，用于连接MySQL数据库 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.26<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 测试包，用于测试 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="分页的方式"><a href="#分页的方式" class="headerlink" title="分页的方式"></a>分页的方式</h3><ol><li>sql语句里面使用<code>limit</code>（SQL代码）。</li><li>使用<code>RowBounds</code>进行分页（Java代码）。</li><li>使用分页插件。</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>对数据库进行增删改的操作后需要提交事务（调用<code>sqlSession.commit()</code>方法）（也可以在获取<code>SqlSession</code>的时候开启自动提交事务）。</li><li><code>javaType</code>指定实体类中属性的类型，<code>ofType</code>指定映射到<code>List</code>或集合中的<code>POJO</code>类型（泛型类型）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList部分源码分析</title>
    <link href="/2021/10/03/ArrayList%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2021/10/03/ArrayList%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><blockquote><p>Java版本：<code>1.8.0_301</code></p><p>源码阅读方式：在IDEA中随便声明一个<code>ArrayList</code>变量，然后 <code>Ctrl + 鼠标左键</code> 点击 <code>ArrayList</code>。</p><p>注：源代码太多了，这里就只分析常用的一些方法。</p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<br>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><code>ArrayList</code>继承了<code>AbstractList</code>类，实现了<code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>和<code>Serializable</code>接口。</p><p><code>AbstractList</code>抽象类使用迭代器实现了<code>List</code>接口的部分方法，当开发人员想实现一个可随机访问（类似数组）的列表时，可以选择继承这个抽象类，这样就可以复用原有的代码了。</p><p><code>List</code>接口里面有很多列表需要的但没有实现的方法，例如：<code>add()</code>、<code>remove()</code>、<code>contains()</code>等。</p><p><code>RandomAccess</code>接口、<code>Cloneable</code>接口和<code>Serializable</code>接口都是标志型接口，里面没有声明任何方法。<code>RandomAccess</code>接口表明该类允许随机访问，<code>Cloneable</code>接口表明该类可以使用<code>clone()</code>方法进行克隆，<code>Serializable</code>接口表明该类可以序列化和反序列化。</p><h2 id="2-成员变量分析"><a href="#2-成员变量分析" class="headerlink" title="2. 成员变量分析"></a>2. 成员变量分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<br>&#123;<br>    <span class="hljs-comment">// 该变量是序列化版本号，当序列化和反序列化时，通过验证该序列化版本号来判断</span><br>    <span class="hljs-comment">// 发送方和接收方是否已为该对象加载了与序列化兼容的类。如果接收方为对象加载</span><br>    <span class="hljs-comment">//了一个序列化版本号不同的类，那么会抛出InvalidClassException异常。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">8683452581122892189L</span>;<br>    <br>    <span class="hljs-comment">// 默认初始化容量为10（当调用无参构造函数创建变量后，调用add函数添加一个变量就会设置容量为10）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>   <br>   <span class="hljs-comment">// 可共享的空数组实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br>    <br>    <span class="hljs-comment">// 使用默认初始化容量时的空数组实例，该变量与EMPTY_ELEMENTDATA的区别就是：</span><br>    <span class="hljs-comment">// 该变量只是在使用无参构造函数时，给elementData赋值，用于区分ArrayList</span><br>    <span class="hljs-comment">// 是使用哪个构造函数进行初始化的。然后在其他方法里面elementData值是否和</span><br>    <span class="hljs-comment">// 该变量相等，相等就设置容量为10</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br>    <br>    <span class="hljs-comment">// 这个Object数组用来存储ArrayList里面的数据，ArrayList的容量就是这个数组的长度</span><br>    <span class="hljs-comment">// 当 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时，添加第一个数据后，</span><br>    <span class="hljs-comment">// 该数组的长度会设置为DEFAULT_CAPACITY</span><br>    <span class="hljs-keyword">transient</span> Object[] elementData; <br>    <br>    <span class="hljs-comment">// ArrayList的大小（elementData实际含有元素的数量）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <br>    <span class="hljs-comment">// 要分配的数组的最大大小，之所以减去8是因为有的Java虚拟机可能会在Object数组里面</span><br>    <span class="hljs-comment">// 加入一些头部字符（header words），如果分配更大的数组时，可能报错OutOfMemoryError</span><br>    <span class="hljs-comment">// 提示：请求的数组大小超出虚拟机限制</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br>        <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-构造函数分析"><a href="#3-构造函数分析" class="headerlink" title="3. 构造函数分析"></a>3. 构造函数分析</h2><p>ArrayList有3个构造函数，分别是：<code>ArrayList(int initialCapacity)</code>、<code>ArrayList()</code>和<code>ArrayList(Collection&lt;? extends E&gt; c)</code>。</p><p>接下来对其进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该构造函数创建一个容量为initialCapacity、实际大小为0的列表</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-comment">// 如果initialCapacity小于0，则抛出异常</span><br>    <span class="hljs-comment">// 如果initialCapacity等于0，则使用共享空数组为elementData赋值</span><br>    <span class="hljs-comment">// 如果initialCapacity大于0，则用new操作符创建一个大小为initialCapacity的数组</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该无参构造函数使用默认容量空数组为elementData赋值，</span><br><span class="hljs-comment">// 首次添加元素时，会将elementData扩容为默认容量10</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><span class="hljs-comment">// 以另一个存储E或E的子类的集合作为参数，创建ArrayList</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-comment">// 调用toArray获取Object数组</span><br>    Object[] a = c.toArray();<br>    <span class="hljs-comment">// 给size赋值，并判断是否为0</span><br>    <span class="hljs-keyword">if</span> ((size = a.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 判断初始化的集合是不是ArrayList类型（ArrayList一定会返回Object[]类型）</span><br>        <span class="hljs-keyword">if</span> (c.getClass() == ArrayList.class) &#123;<br>            elementData = a;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果集合c的实际类型不是ArrayList，那么可能toArray返回值不是Object[]类型</span><br>            elementData = Arrays.copyOf(a, size, Object[].class);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果集合c的大小为0，那么使用共享空数组给elementData赋值</span><br>        elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-ArrayList增加元素"><a href="#4-ArrayList增加元素" class="headerlink" title="4. ArrayList增加元素"></a>4. ArrayList增加元素</h2><h3 id="4-1-add-E-e-方法"><a href="#4-1-add-E-e-方法" class="headerlink" title="4.1 add(E e) 方法"></a>4.1 add(E e) 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在ArrayList的末尾添加一个元素，并返回true</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 调用ensureCapacityInternal方法，对elementData数组进行扩容</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">// 扩容后，将元素添加到elementData末尾</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 接下来是ensureCapacityInternal方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 先调用calculateCapacity方法计算扩容的大小，然后调用ensureExplicitCapacity</span><br>    <span class="hljs-comment">// 方法来扩容</span><br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br><span class="hljs-comment">// 然后来看下calculateCapacity方法，该方法确保调用无参构造函数创建对象后，</span><br><span class="hljs-comment">// 使用add方法添加元素时，ArrayList的容量为10（DEFAULT_CAPACITY）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 首先判断elementData是否是DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br>    <span class="hljs-comment">// 如果是，则返回DEFAULT_CAPACITY和minCapacity中较大的数，即返回</span><br>    <span class="hljs-comment">// 的值一定大于或等于10。如果不是就直接返回minCapacity。</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br><span class="hljs-comment">// 然后是ensureExplicitCapacity方法，该方法确保了扩容后的容量大小一定大于当前容量大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 该变量是抽象类AbstractList里面的变量，该变量主要用来存储列表发生结构性修改的次数</span><br>    <span class="hljs-comment">// 结构性修改就是列表大小改变或者用其它方式修改了列表，导致迭代器访问列表时可能会产生</span><br>    <span class="hljs-comment">// 不正确的结果。如果在使用迭代器访问列表时，该字段的值被修改了，那么会抛出</span><br>    <span class="hljs-comment">// ConcurrentModificationException异常，来响应next、remove、previous、set</span><br>    <span class="hljs-comment">// 或 add 操作。</span><br>    modCount++;<br><br>    <span class="hljs-comment">// 当minCapacity大于当前容量时，才可进行扩容</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><span class="hljs-comment">// 然后是grow方法，该方法用来增加容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 该变量记录旧容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-comment">// 设置新容量为旧容量的约1.5（要进行整型截断）倍</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 将新容量设置为newCapacity和minCapacity中的较大值</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-comment">// 如果新容量大于MAX_ARRAY_SIZE，那么调用hugeCapacity方法重新设置新容量</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br><br>    <span class="hljs-comment">// 使用新容量将elementData扩容</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br><span class="hljs-comment">// 最后是hugeCapacity方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 如果minCapacity小于0，就抛出异常</span><br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>    <span class="hljs-comment">// 当minCapacity大于MAX_ARRAY_SIZE时，返回Integer.MAX_VALUE</span><br>    <span class="hljs-comment">// 当minCapacity小于或等于MAX_ARRAY_SIZE时，返回MAX_ARRAY_SIZE</span><br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>        Integer.MAX_VALUE :<br>    MAX_ARRAY_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后对各种情况进行分析，主要分为以下几种情况：</p><ol><li>调用无参构造函数初始化变量后，首次调用<code>add</code>方法。</li><li>调用无参构造函数初始化变量后，非首次调用<code>add</code>方法</li><li>调用有参构造函数初始化变量后，调用<code>add</code>方法。</li></ol><p>其中，第二种和第三种情况可以合并为一种情况，所以分为两种情况讨论：</p><ul><li>调用无参构造函数初始化变量后，首次调用<code>add</code>方法：<ol><li>调用无参构造函数之后，容量为0，<code>size</code>为0。</li><li>首次调用<code>add</code>方法后，容量为10，<code>size</code>为1。（写过程太麻烦了，所以直接给结果了）</li></ol></li><li>其他情况下，调用<code>add</code>方法：<ol><li>调用<code>add</code>方法，添加元素，此时容量为<code>elementData.length</code>，<code>size</code>是实际存储的元素个数。</li><li>依次调用<code>ensureCapacityInternal</code>、<code>calculateCapacity</code>、<code>ensureExplicitCapacity</code>方法，由于这些方法都比较简单，就直接到<code>grow</code>方法了（<strong>当 size + 1 小于或等于当前容量时，不需要调用grow方法进行扩容</strong>）。</li><li>在<code>grow</code>方法内部，当旧容量小于等于1时，新容量取<code>size + 1</code>的大小，当旧容量大于1时，新容量取1.5倍的旧容量大小（需要进行整型截断）。在此之后，如果新容量大于<code>MAX_ARRAY_SIZE</code>，那么当<em><strong>size + 1</strong></em>（注意：不是用1.5倍的旧容量比较）大于<code>MAX_ARRAY_SIZE</code>时，新容量取<code>Integer.MAX_VALUE</code>，否则新容量取<code>MAX_ARRAY_SIZE</code>。</li></ol></li></ul><h3 id="4-2-add-int-index-E-element-方法"><a href="#4-2-add-int-index-E-element-方法" class="headerlink" title="4.2 add(int index, E element)方法"></a>4.2 add(int index, E element)方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该方法用于在指定位置插入元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">// 判断index的合法性</span><br>    rangeCheckForAdd(index);<br><span class="hljs-comment">// 这个和add(E e)方法一样，所以就重复写了</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">// 将原来的index及之后的位置的元素复制到index + 1及之后的位置</span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>                     size - index);<br>    elementData[index] = element;<br>    size++;<br>&#125;<br><span class="hljs-comment">// 如果index越界了，就抛出异常。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-ArrayList删除元素"><a href="#5-ArrayList删除元素" class="headerlink" title="5. ArrayList删除元素"></a>5. ArrayList删除元素</h2><h3 id="5-1-remove-int-index-方法"><a href="#5-1-remove-int-index-方法" class="headerlink" title="5.1 remove(int index)方法"></a>5.1 remove(int index)方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从ArrayList中删除下标为index的元素，删除方式是将该位置之后的元素整体向左移动一格</span><br><span class="hljs-comment">// 然后将最后一个元素设置为null，并将size减一</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 判断index是否合法，如果不合法就抛出异常</span><br>    rangeCheck(index);<br>    <br><span class="hljs-comment">// 由于发生了结构性变化，故修改该变量</span><br>    modCount++;<br>    <span class="hljs-comment">// 存储被删除的变量，用作返回值</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br><br>    <span class="hljs-comment">// 需要复制的元素个数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 判断元素个数是否合法</span><br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 将index + 1及之后的元素复制到index及之后的位置上</span><br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    <span class="hljs-comment">// 将末尾设置为null，垃圾回收由虚拟机处理</span><br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-remove-Object-o-方法"><a href="#5-2-remove-Object-o-方法" class="headerlink" title="5.2 remove(Object o)方法"></a>5.2 remove(Object o)方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该方法的参数是Object及其子类的类型</span><br><span class="hljs-comment">// 如果传入的参数是int，那么是调用另一个重载方法，按照索引位置删除</span><br><span class="hljs-comment">// 如果传入的参数是Integer，那么是调用该方法，按照元素内容进行删除，删除第一个匹配到的元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">// 判断o是否为null，如果是null就不能用equals方法判断</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-comment">// 判断index位置的元素是否为null</span><br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 调用fastRemove方法删除该元素</span><br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-comment">// 使用equals判断内容是否相等，不能使用==</span><br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                <span class="hljs-comment">// 调用fastRemove方法删除该元素</span><br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// 上面的代码用到了fastRemove方法，故接下来看下fastRemove方法的代码</span><br><span class="hljs-comment">// 该方法与remove(int index)的区别是：该方法是私有的，用户无法调用。</span><br><span class="hljs-comment">// 没有返回值，因为不需要返回值。没有索引的合法性判断，因为传入的参数一定合法。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 发生了结构性变化，故modCount++</span><br>    modCount++;<br>    <span class="hljs-comment">// 需要向左移动的元素个数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 判断需要移动的个数是否合法</span><br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 将index+1及之后的位置的元素复制到index及之后的位置上</span><br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    <span class="hljs-comment">// 将最后一个元素设置为null</span><br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-ArrayList扩容"><a href="#6-ArrayList扩容" class="headerlink" title="6. ArrayList扩容"></a>6. ArrayList扩容</h2><h3 id="6-1-ensureCapacity方法"><a href="#6-1-ensureCapacity方法" class="headerlink" title="6.1 ensureCapacity方法"></a>6.1 ensureCapacity方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该方法是开发人员调用，用于主动扩容的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 判断是否是由无参构造函数创建对象且elementData没有进行任何修改</span><br>    <span class="hljs-comment">// 如果是，则设置最小扩容大小为10（DEFAULT_CAPACITY）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">minExpand</span> <span class="hljs-operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)<br>        <span class="hljs-comment">// any size if not default element table</span><br>        ? <span class="hljs-number">0</span><br>        <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span><br>        <span class="hljs-comment">// supposed to be at default size.</span><br>        : DEFAULT_CAPACITY;<br><span class="hljs-comment">// 如果主动扩容的大小大于minExpand就调用ensureExplicitCapacity方法</span><br>    <span class="hljs-keyword">if</span> (minCapacity &gt; minExpand) &#123;<br>        ensureExplicitCapacity(minCapacity);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 然后是ensureExplicitCapacity方法，该方法确保了扩容后的大小大于扩容前的大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 该变量是抽象类AbstractList里面的变量，该变量主要用来存储列表发生结构性修改的次数</span><br>    <span class="hljs-comment">// 结构性修改就是列表大小改变或者用其它方式修改了列表，导致迭代器访问列表时可能会产生</span><br>    <span class="hljs-comment">// 不正确的结果。如果在使用迭代器访问列表时，该字段的值被修改了，那么会抛出</span><br>    <span class="hljs-comment">// ConcurrentModificationException异常，来响应next、remove、previous、set</span><br>    <span class="hljs-comment">// 或 add 操作。</span><br>    modCount++;<br><br>    <span class="hljs-comment">// 当minCapacity大于当前容量时，才可进行扩容</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><span class="hljs-comment">// 然后是grow方法，该方法用来增加容量，以确保elementData可以容纳至少minCapacity个元素</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 该变量记录旧容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-comment">// 设置新容量为旧容量的约1.5（要进行整型截断）倍</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 将新容量设置为newCapacity和minCapacity中的较大值</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-comment">// 如果新容量大于MAX_ARRAY_SIZE，那么调用hugeCapacity方法重新设置新容量</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br><br>    <span class="hljs-comment">// 使用新容量将elementData扩容</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br><span class="hljs-comment">// 最后是hugeCapacity方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 如果minCapacity小于0，就抛出异常</span><br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>    <span class="hljs-comment">// 当minCapacity大于MAX_ARRAY_SIZE时，返回Integer.MAX_VALUE</span><br>    <span class="hljs-comment">// 当minCapacity小于或等于MAX_ARRAY_SIZE时，返回MAX_ARRAY_SIZE</span><br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>        Integer.MAX_VALUE :<br>    MAX_ARRAY_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>ArrayList扩容分为被动扩容和主动扩容。</p><p>当添加元素时，会在<code>ensureExplicitCapacity</code>方法里面比较添加后的元素个数和<code>elementData.length</code>，如果添加后的元素个数大于<code>elementData.length</code>，就调用<code>grow</code>方法进行扩容，<code>grow</code>方法先会比较添加后的元素个数和1.5倍的旧容量（<code>elementData.length</code>）的大小，在两者之中取较大的为新容量的大小。然后比较新容量大小和最大容量大小，如果新容量的大小大于最大容量额大小，那么判断<strong>添加元素后的元素个数</strong>（<code>minCapacity</code>）是否小于最大容量大小（<code>MAX_ARRAY_SIZE</code>），如果小于，那么就设置新容量大小为最大容量大小（<code>MAX_ARRAY_SIZE</code>），否则就设置<code>Integer.MAX_VALUE</code>为新容量大小。</p><p>还有就是主动扩容，开发人员直接调用<code>ensureCapacity(int minCapacity)</code>方法进行扩容，该扩容方法只能扩大不能缩小。还有就是如果设置的大小小于1.5倍的旧容量，那么会设置扩容为旧容量的1.5倍。</p><p>除了扩容，还有个方法可以减小容量，就是<code>trimToSize()</code>方法，通过该方法可以将<code>elementData.length</code>减小为size的大小。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-行为型模式</title>
    <link href="/2021/10/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/10/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><h1 id="十一个行为型模式"><a href="#十一个行为型模式" class="headerlink" title="十一个行为型模式"></a>十一个行为型模式</h1><h2 id="职责链模式（Chain-of-Responsibility-Pattern）"><a href="#职责链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="职责链模式（Chain of Responsibility Pattern）"></a>职责链模式（Chain of Responsibility Pattern）</h2><p>定义：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。</p><p>职责链模式结构图：</p><p><img src="https://i.loli.net/2021/10/01/E5scurQxN7tMHCo.png" alt="职责链模式结构图"></p><p>职责链模式包含以下两个角色：</p><ol><li><code>Handler</code>（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的<code>successor</code>），作为其对下家的引用。通过该引用，处理者可以连成一条链。</li><li><code>ConcreteHandler</code>（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 职责链模式的核心在于抽象处理者类的设计</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-comment">//维持对下家的引用</span><br>    <span class="hljs-keyword">protected</span> Handler successor;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSuccessor</span><span class="hljs-params">(Handler successor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.successor = successor;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(String request)</span>;<br>&#125;<br><span class="hljs-comment">// 具体处理者是抽象处理者的子类，它具有两大作用：第一是处理请求，不同的具体处理者以不同的形式实现抽象请求处理方法handleRequest()；第二是转发请求，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(String request)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 请求满足条件 */</span>) &#123;<br>            <span class="hljs-comment">// 处理请求</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.successor.handleRequest(request); <span class="hljs-comment">// 转发请求</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>职责链模式有以下两种：</p><ol><li><p>纯的职责链模式</p><p> 一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。</p></li><li><p>不纯的职责链模式</p><p> 在一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。</p></li></ol><p>职责链模式总结：</p><ul><li>主要优点：<ol><li>职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。</li><li>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。</li><li>在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。</li><li>在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。</li></ol></li><li>主要缺点：<ol><li>由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。</li><li>对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</li><li>如果建链不当，可能会造成循环调用，将导致系统陷入死循环。</li></ol></li><li>适用场景：<ol><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li><li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。</li></ol></li></ul><h2 id="命令模式（Command-Pattern）"><a href="#命令模式（Command-Pattern）" class="headerlink" title="命令模式（Command Pattern）"></a>命令模式（Command Pattern）</h2><p>定义：将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作（Action）模式或事务（Transaction）模式。</p><p>命令模式结构图：</p><p><img src="https://i.loli.net/2021/10/01/p6yJ4C8ZsTQ2uaR.png" alt="命令模式结构图"></p><p>命令模式有以下几个角色：</p><ol><li><code>Command</code>（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的<code>execute()</code>等方法，通过这些方法可以调用请求接收者的相关操作。</li><li><code>ConcreteCommand</code>（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现<code>execute()</code>方法时，将调用接收者对象的相关操作（<code>Action</code>）。</li><li><code>Invoker</code>（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的<code>execute()</code>方法，从而实现间接调用请求接收者的相关操作。</li><li><code>Receiver</code>（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 命令模式的关键在于引入了抽象命令类，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联。在最简单的抽象命令类中只包含了一个抽象的execute()方法，每个具体命令类将一个Receiver类型的对象作为一个实例变量进行存储，从而具体指定一个请求的接收者，不同的具体命令类提供了execute()方法的不同实现，并调用不同接收者的请求处理方法。</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 对于请求发送者即调用者而言，将针对抽象命令类进行编程，可以通过构造注入或者设值注入的方式在运行时传入具体命令类对象，并在业务方法中调用命令对象的execute()方法。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> &#123;<br>    <span class="hljs-keyword">private</span> Command command;<br>    <span class="hljs-comment">// 构造注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Invoker</span><span class="hljs-params">(Command command)</span> &#123;<br>        <span class="hljs-built_in">this</span>.command = command;<br>    &#125;<br>    <span class="hljs-comment">// 设值注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command command)</span> &#123;<br>        <span class="hljs-built_in">this</span>.command = command;<br>    &#125;<br>    <span class="hljs-comment">// 业务方法，用于调用命令类的execute()方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        command.execute();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 具体命令类继承了抽象命令类，它与请求接收者相关联，实现了在抽象命令类中声明的execute()方法，并在实现时调用接收者的请求响应方法action()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">private</span> Receiver receiver; <span class="hljs-comment">// 维持一个对请求接收者对象的引用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        receiver.action(); <span class="hljs-comment">// 调用请求接收者的业务处理方法action()</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 请求接收者Receiver类具体实现对请求的业务处理，它提供了action()方法，用于执行与请求相关的操作</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">action</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 具体操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>命令模式总结：</p><ul><li>主要优点：<ol><li>降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。</li><li>新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。</li><li>可以比较容易地设计一个命令队列或宏命令（组合命令）。</li><li>为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。</li></ol></li><li>主要缺点：<ol><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。</li></ol></li><li>适用场景：<ol><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。</li><li>系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作。</li><li>系统需要将一组操作组合在一起形成宏命令。</li></ol></li></ul><h2 id="解释器模式（Interpreter-Pattern）"><a href="#解释器模式（Interpreter-Pattern）" class="headerlink" title="解释器模式（Interpreter Pattern）"></a>解释器模式（Interpreter Pattern）</h2><p>定义：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。解释器模式是一种类行为型模式。</p><p>解释器模式结构图：</p><p><img src="https://i.loli.net/2021/10/01/NlSOiscz1MXv4nY.png" alt="解释器模式结构图"></p><p>解释器模式包含以下几个角色：</p><ol><li><code>AbstractExpression</code>（抽象表达式）：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。</li><li><code>TerminalExpression</code>（终结符表达式）：终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子。</li><li><code>NonterminalExpression</code>（非终结符表达式）：非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。</li><li><code>Context</code>（环境类）：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在解释器模式中，每一种终结符和非终结符都有一个具体类与之对应，正因为使用类来表示每一条文法规则，所以系统将具有较好的灵活性和可扩展性。对于所有的终结符和非终结符，我们首先需要抽象出一个公共父类，即抽象表达式类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context ctx)</span>;<br>&#125;<br><span class="hljs-comment">// 终结符表达式和非终结符表达式类都是抽象表达式类的子类，对于终结符表达式，其代码很简单，主要是对终结符元素的处理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TerminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context ctx)</span> &#123;<br>        <span class="hljs-comment">// 终结符表达式的解释操作</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 对于非终结符表达式，其代码相对比较复杂，因为可以通过非终结符将表达式组合成更加复杂的结构，对于包含两个操作元素的非终结符表达式类，其典型代码如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NonterminalExpression</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExpression</span> &#123;<br>    <span class="hljs-keyword">private</span> AbstractExpression left;<br>    <span class="hljs-keyword">private</span> AbstractExpression right;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NonterminalExpression</span><span class="hljs-params">(AbstractExpression left,AbstractExpression right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(Context ctx)</span> &#123;<br>        <span class="hljs-comment">// 递归调用每一个组成部分的interpret()方法</span><br>        <span class="hljs-comment">// 在递归调用时指定组成部分的连接方式，即非终结符的功能</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 除了上述用于表示表达式的类以外，通常在解释器模式中还提供了一个环境类Context，用于存储一些全局信息，通常在Context中包含了一个HashMap或ArrayList等类型的集合对象（也可以直接由HashMap等集合类充当环境类），存储一系列公共信息，如变量名与值的映射关系（key/value）等，用于在进行具体的解释操作时从中获取相关信息。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">assign</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        <span class="hljs-comment">// 往环境类中设值</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">lookup</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-comment">// 获取存储在环境类中的值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释器模式总结：</p><ul><li>主要优点：<ol><li>易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li><li>每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</li><li>实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。</li><li>增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。</li></ol></li><li>主要缺点：<ol><li>对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。</li><li>执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。</li></ol></li><li>适用场景：<ol><li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。</li><li>一些重复出现的问题可以用一种简单的语言来进行表达。</li><li>一个语言的文法较为简单。</li><li>执行效率不是关键问题。【注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。】</li></ol></li></ul><h2 id="迭代器模式（Iterator-Pattern）"><a href="#迭代器模式（Iterator-Pattern）" class="headerlink" title="迭代器模式（Iterator Pattern）"></a>迭代器模式（Iterator Pattern）</h2><p>定义：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。</p><p>迭代器模式结构图：</p><p><img src="https://i.loli.net/2021/10/01/CanbwQ8TVHM6uRf.png" alt="迭代器模式结构图"></p><p>在迭代器模式中有以下几个角色：</p><ol><li><code>Iterator</code>（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的<code>first()</code>方法，用于访问下一个元素的<code>next()</code>方法，用于判断是否还有下一个元素的<code>hasNext()</code>方法，用于获取当前元素的<code>currentItem()</code>方法等，在具体迭代器中将实现这些方法。</li><li><code>ConcreteIterator</code>（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。</li><li><code>Aggregate</code>（抽象聚合类）：它用于存储和管理元素对象，声明一个<code>createIterator()</code>方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。</li><li><code>ConcreteAggregate</code>（具体聚合类）：它实现了在抽象聚合类中声明的<code>createIterator()</code>方法，该方法返回一个与该具体聚合类对应的具体迭代器<code>ConcreteIterator</code>实例。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在抽象迭代器中声明了用于遍历聚合对象中所存储元素的方法</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 将游标指向第一个元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 将游标指向下一个元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 判断是否存在下一个元素</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 获取游标指向的当前元素</span><br>&#125;<br><span class="hljs-comment">// 在具体迭代器中将实现抽象迭代器声明的遍历数据的方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">private</span> ConcreteAggregate objects; <span class="hljs-comment">// 维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor; <span class="hljs-comment">// 定义一个游标，用于记录当前访问位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteIterator</span><span class="hljs-params">(ConcreteAggregate objects)</span> &#123;<br>        <span class="hljs-built_in">this</span>.objects = objects;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span> &#123; ...... &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123; ...... &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123; ...... &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">currentItem</span><span class="hljs-params">()</span> &#123; ...... &#125;<br>&#125;<br><span class="hljs-comment">// 聚合类用于存储数据并负责创建迭代器对象</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>    Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 具体聚合类作为抽象聚合类的子类，一方面负责存储数据，另一方面实现了在抽象聚合类中声明的工厂方法createIterator()，用于返回一个与该具体聚合类对应的具体迭代器对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteAggregate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>    ......<br>        <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">createIterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteIterator</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代器模式总结：</p><p>迭代器模式是一种使用频率非常高的设计模式，通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成。由于很多编程语言的类库都已经实现了迭代器模式，因此在实际开发中，我们只需要直接使用Java、C#等语言已定义好的迭代器即可，迭代器已经成为我们操作聚合对象的基本工具之一。</p><ul><li>主要优点：<ol><li>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li><li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。</li></ol></li><li>主要缺点：<ol><li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li><li>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。</li></ol></li><li>适用场景：<ol><li>访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。</li><li>需要为一个聚合对象提供多种遍历方式。</li><li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。</li></ol></li></ul><h2 id="中介者模式（Mediator-Pattern）"><a href="#中介者模式（Mediator-Pattern）" class="headerlink" title="中介者模式（Mediator Pattern）"></a>中介者模式（Mediator Pattern）</h2><p>定义：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</p><p>中介者模式结构图；</p><p><img src="https://i.loli.net/2021/10/01/omZY5gPUAcGnxlb.png" alt="中介者模式结构图"></p><p>在中介者模式中包含以下几个角色：</p><ol><li><code>Mediator</code>（抽象中介者）：它定义一个接口，该接口用于与各同事对象之间进行通信。</li><li><code>ConcreteMediator</code>（具体中介者）：它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用。</li><li><code>Colleague</code>（抽象同事类）：它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现，同时它维持了一个对抽象中介者类的引用，其子类可以通过该引用来与中介者通信。</li><li><code>ConcreteColleague</code>（具体同事类）：它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在中介者模式中，典型的抽象中介者类代码如下所示：</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;<br>    <span class="hljs-keyword">protected</span> ArrayList&lt;Colleague&gt; colleagues; <span class="hljs-comment">// 用于存储同事对象</span><br>    <span class="hljs-comment">// 注册方法，用于增加同事对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Colleague colleague)</span> &#123;<br>        colleagues.add(colleague);<br>    &#125;<br>    <span class="hljs-comment">// 声明抽象的业务方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 在抽象中介者中可以定义一个同事类的集合，用于存储同事对象并提供注册方法，同时声明了具体中介者类所具有的方法。在具体中介者类中将实现这些抽象方法，典型的具体中介者类代码如下所示：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteMediator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mediator</span> &#123;<br>    <span class="hljs-comment">//实现业务方法，封装同事之间的调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        ......<br>            colleagues.get(<span class="hljs-number">0</span>).method1(); <span class="hljs-comment">// 通过中介者调用同事类的方法</span><br>        ......<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 在抽象同事类中维持了一个抽象中介者的引用，用于调用中介者的方法</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Colleague</span> &#123;<br>    <span class="hljs-keyword">protected</span> Mediator mediator; <span class="hljs-comment">// 维持一个抽象中介者的引用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Colleague</span><span class="hljs-params">(Mediator mediator)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mediator = mediator;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 声明自身方法，处理自己的行为</span><br>    <span class="hljs-comment">//定义依赖方法，与中介者进行通信</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        mediator.operation();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 在抽象同事类中声明了同事类的抽象方法，而在具体同事类中将实现这些方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteColleague</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Colleague</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteColleague</span><span class="hljs-params">(Mediator mediator)</span> &#123;<br>        <span class="hljs-built_in">super</span>(mediator);<br>    &#125;<br>    <span class="hljs-comment">// 实现自身方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        ......<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>中介者模式总结：</p><p>中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。中介者模式在事件驱动类软件中应用较为广泛，特别是基于GUI（Graphical User Interface，图形用户界面）的应用软件，此外，在类与类之间存在错综复杂的关联关系的系统中，中介者模式都能得到较好的应用。</p><ul><li>主要优点：<ol><li>中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构。</li><li>中介者模式可将各同事对象解耦。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。</li><li>可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展。</li></ol></li><li>主要缺点：<ol><li>在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li></ol></li><li>适用场景：<ol><li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li><li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类。</li></ol></li></ul><h2 id="备忘录模式（Memento-Pattern）"><a href="#备忘录模式（Memento-Pattern）" class="headerlink" title="备忘录模式（Memento Pattern）"></a>备忘录模式（Memento Pattern）</h2><p>定义：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为Token。</p><p>备忘录模式结构图：</p><p><img src="https://i.loli.net/2021/10/01/5n7uI2QwsW981cy.png" alt="备忘录模式结构图"></p><p>备忘录模式中有以下几个角色：</p><ol><li><code>Originator</code>（原发器）：它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器。</li><li><code>Memento</code>（备忘录）：存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用，原发器的设计在不同的编程语言中实现机制会有所不同。</li><li><code>Caretaker</code>（负责人）：负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在使用备忘录模式时，首先应该存在一个原发器类Originator，在真实业务中，原发器类是一个具体的业务类，它包含一些用于存储成员数据的属性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span> &#123;<br>    <span class="hljs-keyword">private</span> String state;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Originator</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-comment">// 创建一个备忘录对象</span><br>    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">createMemento</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memento</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-comment">// 根据备忘录对象恢复原发器状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">restoreMemento</span><span class="hljs-params">(Memento m)</span> &#123;<br>        state = m.state;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(String state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state=state;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.state;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 对于备忘录类Memento而言，它通常提供了与原发器相对应的属性（可以是全部，也可以是部分）用于存储原发器的状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> &#123;<br>    <span class="hljs-keyword">private</span> String state;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Memento</span><span class="hljs-params">(Originator o)</span> &#123;<br>        state = o.getState();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(String state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state=state;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.state;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 对于负责人类Caretaker，它用于保存备忘录对象，并提供getMemento()方法用于向客户端返回一个备忘录对象，原发器通过使用这个备忘录对象可以回到某个历史状态。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Caretaker</span> &#123;<br>    <span class="hljs-keyword">private</span> Memento memento;<br>    <span class="hljs-keyword">public</span> Memento <span class="hljs-title function_">getMemento</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> memento;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemento</span><span class="hljs-params">(Memento memento)</span> &#123;<br>        <span class="hljs-built_in">this</span>.memento=memento;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>备忘录模式总结：</p><p>备忘录模式在很多软件的使用过程中普遍存在，但是在应用软件开发中，它的使用频率并不太高，因为现在很多基于窗体和浏览器的应用软件并没有提供撤销操作。如果需要为软件提供撤销功能，备忘录模式无疑是一种很好的解决方案。在一些字处理软件、图像编辑软件、数据库管理系统等软件中备忘录模式都得到了很好的应用。</p><ul><li>主要优点：<ol><li>它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。</li><li>备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。</li></ol></li><li>主要缺点：<ol><li>资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。</li></ol></li><li>适用场景：<ol><li>保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作。</li><li>防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。</li></ol></li></ul><h2 id="观察者模式（Observer-Pattern）"><a href="#观察者模式（Observer-Pattern）" class="headerlink" title="观察者模式（Observer Pattern）"></a>观察者模式（Observer Pattern）</h2><p>定义：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish&#x2F;Subscribe）模式、模型-视图（Model&#x2F;View）模式、源-监听器（Source&#x2F;Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。</p><p>观察者模式结构图：</p><p><img src="https://i.loli.net/2021/10/01/qISuYk6ABxXPT4f.png" alt="观察者模式结构图"></p><p>在观察者模式结构图中有以下几个角色：</p><ol><li><code>Subject</code>（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法<code>notify()</code>。目标类可以是接口，也可以是抽象类或具体类。</li><li><code>ConcreteSubject</code>（具体目标）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</li><li><code>Observer</code>（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法<code>update()</code>，因此又称为抽象观察者。</li><li><code>ConcreteObserver</code>（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者<code>Observer</code>中定义的<code>update()</code>方法。通常在实现时，可以调用具体目标类的<code>attach()</code>方法将自己添加到目标类的集合中或通过<code>detach()</code>方法将自己从目标类的集合中删除。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 观察目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">// 定义一个观察者集合用于存储所有观察者对象</span><br>    <span class="hljs-keyword">protected</span> ArrayList&lt;Observer&gt; observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 注册方法，用于向观察者集合中增加一个观察者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        observers.add(observer);<br>    &#125;<br>    <span class="hljs-comment">// 注销方法，用于在观察者集合中删除一个观察者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        observers.remove(observer);<br>    &#125;<br>    <span class="hljs-comment">// 声明抽象通知方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 具体目标类ConcreteSubject是实现了抽象目标类Subject的一个具体子类，其典型代码如下所示：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">// 实现通知方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 遍历观察者集合，调用每一个观察者的响应方法</span><br>        <span class="hljs-keyword">for</span>(Object obs:observers) &#123;<br>            obs.update();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 抽象观察者角色一般定义为一个接口，通常只声明一个update()方法，为不同观察者的更新（响应）行为定义相同的接口，这个方法在其子类中实现，不同的观察者具有不同的响应方法</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">// 声明响应方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 在具体观察者ConcreteObserver中实现了update()方法，其典型代码如下所示：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-comment">// 实现响应方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 具体响应代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>观察者模式总结：</p><p>观察者模式是一种使用频率非常高的设计模式，无论是移动应用、Web应用或者桌面应用，观察者模式几乎无处不在，它为实现对象之间的联动提供了一套完整的解决方案，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。观察者模式广泛应用于各种编程语言的GUI事件处理的实现，在基于事件的XML解析技术（如<code>SAX2</code>）以及Web事件处理中也都使用了观察者模式。</p><ul><li>主要优点：<ol><li>观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。</li><li>观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。</li><li>观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。</li></ol></li><li>主要缺点：<ol><li>如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ol></li><li>适用场景：<ol><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ol></li></ul><h2 id="状态模式（State-Pattern）"><a href="#状态模式（State-Pattern）" class="headerlink" title="状态模式（State Pattern）"></a>状态模式（State Pattern）</h2><p>定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。</p><p>状态模式结构图：</p><p><img src="https://i.loli.net/2021/10/01/wzQvnWGb8INCeSL.png" alt="状态模式结构图"></p><p>在状态码模式结构图中包含以下几个角色：</p><ol><li><code>Context</code>（环境类）：环境类又称为上下文类，它是拥有多种状态的对象。由于环境类的状态存在多样性且在不同状态下对象的行为有所不同，因此将状态独立出去形成单独的状态类。在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象。</li><li><code>State</code>（抽象状态类）：它用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现类这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中。</li><li><code>ConcreteState</code>（具体状态类）：它是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在状态模式中，我们将对象在不同状态下的行为封装到不同的状态类中，为了让系统具有更好的灵活性和可扩展性，同时对各状态下的共有行为进行封装，我们需要对状态进行抽象，引入了抽象状态类角色</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-comment">// 声明抽象业务方法，不同的具体状态类可以不同的实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 在抽象状态类的子类即具体状态类中实现了在抽象状态类中声明的业务方法，不同的具体状态类可以提供完全不同的方法实现，在实际使用时，在一个状态类中可能包含多个业务方法，如果在具体状态类中某些业务方法的实现完全相同，可以将这些方法移至抽象状态类，实现代码的复用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 方法具体实现代码</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 环境类维持一个对抽象状态类的引用，通过setState()方法可以向环境类注入不同的状态对象，再在环境类的业务方法中调用状态对象的方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    <span class="hljs-keyword">private</span> State state; <span class="hljs-comment">// 维持一个对抽象状态对象的引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value; <span class="hljs-comment">// 其他属性值，该属性值的变化可能会导致对象状态发生变化</span><br>    <span class="hljs-comment">// 设置状态对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(State state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 其他代码</span><br>        state.handle(); <span class="hljs-comment">// 调用状态对象的业务方法</span><br>        <span class="hljs-comment">// 其他代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>状态模式总结：</p><p>状态模式将一个对象在不同状态下的不同行为封装在一个个状态类中，通过设置不同的状态对象可以让环境对象拥有不同的行为，而状态转换的细节对于客户端而言是透明的，方便了客户端的使用。在实际开发中，状态模式具有较高的使用频率，在工作流和游戏开发中状态模式都得到了广泛的应用，例如公文状态的转换、游戏中角色的升级等。</p><ul><li>主要优点：<ol><li>封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。</li><li>将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。</li><li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li></ol></li><li>主要缺点：<ol><li>状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。</li><li>状态模式对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li></ol></li><li>适用场景：<ol><li>对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化。</li><li>在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。</li></ol></li></ul><h2 id="策略模式（Strategy-Pattern）"><a href="#策略模式（Strategy-Pattern）" class="headerlink" title="策略模式（Strategy Pattern）"></a>策略模式（Strategy Pattern）</h2><p>定义：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客<br>户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式。</p><p>策略模式结构图：</p><p><img src="https://i.loli.net/2021/10/01/FLb7OAhu6JIwvZ2.png" alt="策略模式结构图"></p><p>在策略模式结构图中有以下几个角色：</p><ol><li><code>Context</code>（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。</li><li><code>Strategy</code>（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。</li><li><code>ConcreteStrategy</code>（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在使用策略模式时，我们需要将算法从Context类中提取出来，首先应该创建一个抽象策略类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractStrategy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">()</span>; <span class="hljs-comment">//声明抽象算法</span><br>&#125;<br><span class="hljs-comment">// 然后再将封装每一种具体算法的类作为该抽象策略类的子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStrategyA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractStrategy</span> &#123;<br>    <span class="hljs-comment">// 算法的具体实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 算法A</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 对于Context类而言，在它与抽象策略类之间建立一个关联关系</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    <span class="hljs-keyword">private</span> AbstractStrategy strategy; <span class="hljs-comment">// 维持一个对抽象策略类的引用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStrategy</span><span class="hljs-params">(AbstractStrategy strategy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.strategy = strategy;<br>    &#125;<br>    <span class="hljs-comment">// 调用策略类中的算法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">algorithm</span><span class="hljs-params">()</span> &#123;<br>        strategy.algorithm();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>策略模式总结：</p><p>策略模式用于算法的自由切换和扩展，它是应用较为广泛的设计模式之一。策略模式对应于解决某一问题的一个算法族，允许用户从该算法族中任选一个算法来解决某一问题，同时可以方便地更换算法或者增加新的算法。只要涉及到算法的封装、复用和切换都可以考虑使用策略模式。</p><ul><li>主要优点：<ol><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。</li><li>策略模式提供了一种可以替换继承关系的办法。如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合“单一职责原则”，决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换。</li><li>使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。</li><li>策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。</li></ol></li><li>主要缺点：<ol><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。</li><li>策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。</li><li>无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。</li></ol></li><li>适用场景：<ol><li>一个系统需要动态地在几种算法中选择一种，那么可以将这些算法封装到一个个的具体算法类中，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体算法类均有统一的接口，根据“里氏代换原则”和面向对象的多态性，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象。</li><li>一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句。</li><li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性。</li></ol></li></ul><h2 id="模板方法模式（Template-Method-Pattern）"><a href="#模板方法模式（Template-Method-Pattern）" class="headerlink" title="模板方法模式（Template Method Pattern）"></a>模板方法模式（Template Method Pattern）</h2><p>定义：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法模式是一种基于继承的代码复用技术，它是一种类行为型模式。</p><p>模板方法模式结构图：</p><p><img src="https://i.loli.net/2021/10/01/Mihx9fCwDLsjqJe.png" alt="模板方法模式结构图"></p><p>在模板方法模式中有以下几个角色：</p><ol><li><code>AbstractClass</code>（抽象类）：在抽象类中定义了一系列基本操作(PrimitiveOperations)，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法(Template Method)，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。</li><li><code>ConcreteClass</code>（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象类的典型代码如下：</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span><br>&#123;<br>    <span class="hljs-comment">// 模板方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">TemplateMethod</span><span class="hljs-params">()</span><br>    &#123;<br>        PrimitiveOperation1();<br>        PrimitiveOperation2();<br>        PrimitiveOperation3();<br>    &#125;<br>    <span class="hljs-comment">// 基本方法—具体方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">PrimitiveOperation1</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">// 实现代码</span><br>    &#125;<br>    <span class="hljs-comment">// 基本方法—抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">PrimitiveOperation2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 基本方法—钩子方法</span><br>    <span class="hljs-keyword">public</span> virtual <span class="hljs-keyword">void</span> <span class="hljs-title function_">PrimitiveOperation3</span><span class="hljs-params">()</span>&#123; &#125;<br>&#125;<br><span class="hljs-comment">// 在抽象类的子类中提供抽象步骤的实现，也可覆盖父类中已经实现的具体方法，典型代码如下：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass</span> : AbstractClass<br>&#123;<br>    <span class="hljs-keyword">public</span> override <span class="hljs-keyword">void</span> <span class="hljs-title function_">PrimitiveOperation2</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">//实现代码</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> override <span class="hljs-keyword">void</span> <span class="hljs-title function_">PrimitiveOperation3</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">//实现代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板方法模式总结：</p><p>模板方法模式是基于继承的代码复用技术，它体现了面向对象的诸多重要思想，是一种使用较为频繁的模式。模板方法模式广泛应用于框架设计中，以确保通过父类来控制处理流程的逻辑顺序（如框架的初始化，测试流程的设置等）。</p><ul><li>主要优点：<ol><li>在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。</li><li>模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。</li><li>可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。</li><li>在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。</li></ol></li><li>主要缺点：<ol><li>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。</li></ol></li><li>适用场景：<ol><li>对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li></ol></li></ul><h2 id="访问者模式（Visitor-Pattern）"><a href="#访问者模式（Visitor-Pattern）" class="headerlink" title="访问者模式（Visitor Pattern）"></a>访问者模式（Visitor Pattern）</h2><p>定义：提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。</p><p>访问者模式结构图：</p><p><img src="https://i.loli.net/2021/10/01/x89gYfriVuRObWC.png" alt="访问者模式结构图"></p><p>在访问者模式结构图中有以下几个角色：</p><ol><li><code>Vistor</code>（抽象访问者）：抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作。</li><li><code>ConcreteVisitor</code>（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素。</li><li><code>Element</code>（抽象元素）：抽象元素一般是抽象类或者接口，它定义一个accept()方法，该方法通常以一个抽象访问者作为参数。</li><li><code>ConcreteElement</code>（具体元素）：具体元素实现了accept()方法，在accept()方法中调用访问者的访问方法以便完成对一个元素的操作。</li><li><code>ObjectStructure</code>（对象结构）：对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象，如一个List对象或一个Set对象。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在访问者模式中，抽象访问者定义了访问元素对象的方法，通常为每一种类型的元素对象都提供一个访问方法，而具体访问者可以实现这些访问方法。这些访问方法的命名一般有两种方式：一种是直接在方法名中标明待访问元素对象的具体类型，如visitElementA(ElementAelementA)，还有一种是统一取名为visit()，通过参数类型的不同来定义一系列重载的visit()方法。当然，如果所有的访问者对某一类型的元素的访问操作都相同，则可以将操作代码移到抽象访问者类中，其典型代码如下所示：</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Visitor</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteElementA elementA)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteElementB elementB)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteElementC elementC)</span><br>    &#123;<br>        <span class="hljs-comment">//元素ConcreteElementC操作代码</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 在这里使用了重载visit()方法的方式来定义多个方法用于操作不同类型的元素对象。在抽象访问者Visitor类的子类ConcreteVisitor中实现了抽象的访问方法，用于定义对不同类型元素对象的操作，具体访问者类典型代码如下所示：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Visitor</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteElementA elementA)</span><br>    &#123;<br>        <span class="hljs-comment">// 元素ConcreteElementA操作代码</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(ConcreteElementB elementB)</span><br>    &#123;<br>        <span class="hljs-comment">// 元素ConcreteElementB操作代码</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 对于元素类而言，在其中一般都定义了一个accept()方法，用于接受访问者的访问，典型的抽象元素类代码如下所示：</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span>;<br>&#125;<br><span class="hljs-comment">// 需要注意的是该方法传入了一个抽象访问者Visitor类型的参数，即针对抽象访问者进行编程，而不是具体访问者，在程序运行时再确定具体访问者的类型，并调用具体访问者对象的visit()方法实现对元素对象的操作。在抽象元素类Element的子类中实现了accept()方法，用于接受访问者的访问，在具体元素类中还可以定义不同类型的元素所特有的业务方法，其典型代码如下所示：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Element</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span><br>    &#123;<br>        visitor.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationA</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">// 业务方法</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 在访问者模式中，对象结构是一个集合，它用于存储元素对象并接受访问者的访问，其典型代码如下所示：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectStructure</span><br>&#123;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;Element&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">//定义一个集合用于存储元素对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor visitor)</span><br>    &#123;<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> list.iterator();<br>        <span class="hljs-keyword">while</span>(i.hasNext())<br>        &#123;<br>            i.next().accept(visitor); <span class="hljs-comment">//遍历访问集合中的每一个元素</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addElement</span><span class="hljs-params">(Element element)</span><br>    &#123;<br>        list.add(element);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(Element element)</span><br>    &#123;<br>        list.remove(element);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问者模式总结：</p><p>由于访问者模式的使用条件较为苛刻，本身结构也较为复杂，因此在实际应用中使用频率不是特别高。当系统中存在一个较为复杂的对象结构，且不同访问者对其所采取的操作也不相同时，可以考虑使用访问者模式进行设计。在XML文档解析、编译器的设计、复杂集合对象的处理等领域访问者模式得到了一定的应用。</p><ul><li>主要优点：<ol><li>增加新的访问操作很方便。使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合“开闭原则”。</li><li>将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。</li><li>让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。</li></ol></li><li>主要缺点：<ol><li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”的要求。</li><li>破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问。</li></ol></li><li>适用场景：<ol><li>一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。访问者模式使得我们可以将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离。</li><li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-结构型模式</title>
    <link href="/2021/10/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/10/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><h1 id="七个结构型模式"><a href="#七个结构型模式" class="headerlink" title="七个结构型模式"></a>七个结构型模式</h1><h2 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h2><p>定义：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器（Wrapper）。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><p>适配器模式结构图如下：</p><p><img src="https://i.loli.net/2021/10/01/tu4PLZDG9QWcY5q.png" alt="适配器模式结构图"></p><p>在适配器模式结构图中有以下几个角色：</p><ol><li><code>Target</code>（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</li><li><code>Adapter</code>（适配器类）：适配器可以调用另一个接口，作为一个转换器，对<code>Adaptee</code>和<code>Target</code>进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承<code>Target</code>并关联一个<code>Adaptee</code>对象使二者产生联系。</li><li><code>Adaptee</code>（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li></ol><p>根据对象适配器模式结构图，在对象适配器中，客户端需要调用<code>request()</code>方法，而适配者类<code>Adaptee</code>没有该方法，但是它所提供的<code>specificRequest()</code>方法却是客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类<code>Adapter</code>，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的<code>request()</code>方法中调用适配者的<code>specificRequest()</code>方法。因为适配器类与适配者类是关联关系（也可称之为委派关系），所以这种适配器模式称为对象适配器模式。</p><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 典型的对象适配器代码如下所示：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Target</span> &#123;<br>    <span class="hljs-keyword">private</span> Adaptee adaptee; <span class="hljs-comment">//维持一个对适配者对象的引用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span> &#123;<br>        <span class="hljs-built_in">this</span>.adaptee = adaptee;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">()</span> &#123;<br>        adaptee.specificRequest(); <span class="hljs-comment">//转发调用</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>适配器模式总结：</p><p>适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，它是一种使用频率非常高的设计模式，在软件开发中得以广泛应用，在Spring等开源框架、驱动程序设计（如JDBC中的数据库驱动程序）中也使用了适配器模式。</p><ul><li>主要优点：<ol><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li><li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li><li>（类适配器）由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</li><li>（对象适配器）一个对象适配器可以把多个不同的适配者适配到同一个目标；</li><li>（对象适配器）可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。</li></ol></li><li>主要缺点：<ol><li>（类适配器）对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；</li><li>（类适配器）适配者类不能为最终类，如在Java中不能为final类，C#中不能为sealed类；</li><li>（类适配器）在Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</li><li>（对象适配器）与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</li></ol></li><li>适用场景：<ol><li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</li><li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ol></li></ul><h2 id="桥接模式（Bridge-Pattern）"><a href="#桥接模式（Bridge-Pattern）" class="headerlink" title="桥接模式（Bridge Pattern）"></a>桥接模式（Bridge Pattern）</h2><p>定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体（Handle and Body）模式或接口（Interface）模式。</p><p>桥接模式结构图：</p><p><img src="https://i.loli.net/2021/10/01/Dnbti4pEgc6jArx.png" alt="桥接模式结构图"></p><p>在桥接模式结构图中有以下几个角色：</p><ol><li><code>Abstraction</code>（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个<code>Implementor</code>（实现类接口）类型的对象并可以维护该对象，它与<code>Implementor</code>之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。</li><li><code>RefinedAbstraction</code>（扩充抽象类）：扩充由<code>Abstraction</code>定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在<code>Abstraction</code>中声明的抽象业务方法，在<code>RefinedAbstraction</code>中可以调用在<code>Implementor</code>中定义的业务方法。</li><li><code>Implementor</code>（实现类接口）：定义实现类的接口，这个接口不一定要与<code>Abstraction</code>的接口完全一致，事实上这两个接口可以完全不同，一般而言，<code>Implementor</code>接口仅提供基本操作，而<code>Abstraction</code>定义的接口可能会做更多更复杂的操作。<code>Implementor</code>接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在<code>Abstraction</code>中不仅拥有自己的方法，还可以调用到<code>Implementor</code>中定义的方法，使用关联关系来替代继承关系。</li><li><code>ConcreteImplementor</code>（具体实现类）：具体实现<code>Implementor</code>接口，在不同的<code>ConcreteImplementor</code>中提供基本操作的不同实现，在程序运行时，<code>ConcreteImplementor</code>对象将替换其父类对象，提供给抽象类具体的业务操作方法。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在具体编码实现时，由于在桥接模式中存在两个独立变化的维度，为了使两者之间耦合度降低，首先需要针对两个不同的维度提取抽象类和实现类接口，并建立一个抽象关联关系。对于“实现部分”维度，典型的实现类接口代码如下所示：</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Implementor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationImpl</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 对于另一“抽象部分”维度而言，其典型的抽象类代码如下所示：</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Abstraction</span> &#123;<br>    <span class="hljs-keyword">protected</span> Implementor impl; <span class="hljs-comment">// 定义实现类接口对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setImpl</span><span class="hljs-params">(Implementor impl)</span> &#123;<br>        <span class="hljs-built_in">this</span>.impl = impl;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 声明抽象业务方法</span><br>&#125;<br><span class="hljs-comment">// 在抽象类Abstraction中定义了一个实现类接口类型的成员对象impl，再通过注入的方式给该对象赋值，一般将该对象的可见性定义为protected，以便在其子类中访问Implementor的方法，其子类一般称为扩充抽象类或细化抽象类(RefinedAbstraction)，典型的RefinedAbstraction类代码如下所示：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefinedAbstraction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Abstraction</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 业务代码</span><br>        impl.operationImpl(); <span class="hljs-comment">// 调用实现类的方法</span><br>        <span class="hljs-comment">// 业务代码</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>桥接模式总结：</p><p>桥接模式是设计Java虚拟机和实现JDBC等驱动程序的核心模式之一，应用较为广泛。在软件开发中如果一个类或一个系统有多个变化维度时，都可以尝试使用桥接模式对其进行设计。桥接模式为多维度变化的系统提供了一套完整的解决方案，并且降低了系统的复杂度。</p><ul><li>主要优点：<ol><li>分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象。</li><li>在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。</li><li>桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。</li></ol></li><li>主要缺点：<ol><li>桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。</li></ol></li><li>适用场景：<ol><li>如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li><li>“抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li><li>一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。</li><li>对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li></ol></li></ul><h2 id="组合模式（Composite-Pattern）"><a href="#组合模式（Composite-Pattern）" class="headerlink" title="组合模式（Composite Pattern）"></a>组合模式（Composite Pattern）</h2><p>定义：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”（Part-Whole）模式，它是一种对象结构型模式。</p><p>组合模式结构图：</p><p><img src="https://i.loli.net/2021/10/01/24pxC6cfHWEvokS.png" alt="组合模式结构图"></p><p>在组合模式结构图中有以下几个角色：</p><ol><li><code>Component</code>（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。</li><li><code>Leaf</code>（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。</li><li><code>Composite</code>（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象构件的典型代码如下：</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span>; <span class="hljs-comment">// 增加成员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span>; <span class="hljs-comment">// 删除成员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>; <span class="hljs-comment">// 获取成员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 业务方法</span><br>&#125;<br><span class="hljs-comment">// 叶子构件的代码如下：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span> &#123;<br>        <span class="hljs-comment">// 异常处理或错误提示</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span> &#123;<br>        <span class="hljs-comment">// 异常处理或错误提示</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-comment">// 异常处理或错误提示</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 叶子构件具体业务方法的实现</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 容器构件的代码如下：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;Component&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Component c)</span> &#123;<br>        list.add(c);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Component c)</span> &#123;<br>        list.remove(c);<br>    &#125;<br>    <span class="hljs-keyword">public</span> Component <span class="hljs-title function_">getChild</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">return</span> list.get(i);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 容器构件具体业务方法的实现</span><br>        <span class="hljs-comment">// 递归调用成员构件的业务方法</span><br>        <span class="hljs-keyword">for</span>(Component obj:list) &#123;<br>            obj.operation();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>组合模式总结：</p><p>组合模式使用面向对象的思想来实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型设计模式，Java SE中的AWT和Swing包的设计就基于组合模式，在这些界面包中为用户提供了大量的容器构件（如Container）和成员构件（如Checkbox、Button和TextComponent等）。</p><ul><li>主要优点：<ol><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li><li>在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li></ol></li><li>主要缺点：<ol><li>在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。</li></ol></li><li>适用场景：<ol><li>在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。</li><li>在一个使用面向对象语言开发的系统中需要处理一个树形结构。</li><li>在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。</li></ol></li></ul><h2 id="装饰模式（Decorator-Pattern）"><a href="#装饰模式（Decorator-Pattern）" class="headerlink" title="装饰模式（Decorator Pattern）"></a>装饰模式（Decorator Pattern）</h2><p>定义：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</p><p>装饰模式的结构如下图：</p><p><img src="https://i.loli.net/2021/10/01/rsxf5mJRkCNHT7A.png" alt="装饰模式结构图"></p><p>装饰模式结构图里面有以下几个角色：</p><ul><li><code>Component</code>（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</li><li><code>ConcreteComponent</code>（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。</li><li><code>Decorator</code>（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</li><li><code>ConcreteDecorator</code>（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</li></ul><p>装饰模式的核心在于抽象装饰类的设计，它的典型代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Component</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Component component; <span class="hljs-comment">//维持一个对抽象构件对象的引用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Decorator</span><span class="hljs-params">(Component component)</span> <span class="hljs-comment">//注入一个抽象构件类型的对象</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.component=component;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span><br>    &#123;<br>        component.operation(); <span class="hljs-comment">//调用原有业务方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 在抽象装饰类<code>Decorator</code>中定义了一个<code>Component</code>类型的对象<code>component</code>，维持一个对抽象构件对象的引用，并可以通过构造方法或<code>Setter</code>方法将一个<code>Component</code>类型的对象注入进来，同时由于<code>Decorator</code>类实现了抽象构件<code>Component</code>接口，因此需要实现在其中声明的业务方法<code>operation()</code>，需要注意的是在<code>Decorator</code>中并未真正实现<code>operation()</code>方法，而只是调用原有<code>component</code>对象的<code>operation()</code>方法，它没有真正实施装饰，而是提供一个统一的接口，将具体装饰过程交给子类完成。</p><p>在<code>Decorator</code>的子类即具体装饰类中将继承<code>operation()</code>方法并根据需要进行扩展，典型的具体装饰类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Decorator</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcreteDecorator</span><span class="hljs-params">(Component component)</span><br>    &#123;<br>        <span class="hljs-built_in">super</span>(component);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-built_in">super</span>.operation(); <span class="hljs-comment">//调用原有业务方法</span><br>        addedBehavior(); <span class="hljs-comment">//调用新增业务方法</span><br>    &#125;<br>    <span class="hljs-comment">//新增业务方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addedBehavior</span><span class="hljs-params">()</span><br>    &#123;<br>        ……<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在具体装饰类中可以调用到抽象装饰类的<code>operation()</code>方法，同时可以定义新的业务方法，如<code>addedBehavior()</code>。</p><p>由于在抽象装饰类<code>Decorator</code>中注入的是<code>Component</code>类型的对象，因此我们可以将一个具体构件对象注入其中，再通过具体装饰类来进行装饰；此外，我们还可以将一个已经装饰过的<code>Decorator</code>子类的对象再注入其中进行多次装饰，从而对原有功能的多次扩展。</p><p>在实际使用中，装饰模式有两种，一种是半透明（<code>Semi-transparent</code>）装饰模式，另一种则是透明（<code>Transparent</code>）装饰模式。标准的装饰模式是透明装饰模式。下面是两种装饰模式的详细介绍：</p><p>（1）透明装饰模式<br>在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。也就是应该使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Component c, c1; <span class="hljs-comment">// 使用抽象构件类型定义对象</span><br>c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteComponent</span>();<br>c1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteDecorator</span> (c);<br><span class="hljs-comment">// 而不应该使用如下代码：</span><br>ConcreteComponent c; <span class="hljs-comment">// 使用具体构件类型定义对象</span><br>c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteComponent</span>();<br><span class="hljs-comment">// 或</span><br>ConcreteDecorator c1; <span class="hljs-comment">// 使用具体装饰类型定义对象</span><br>c1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteDecorator</span>(c);<br><br></code></pre></td></tr></table></figure><p>透明装饰模式可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别，此外，还可以对一个已装饰过的对象进行多次装饰，得到更为复杂、功能更为强大的对象。在实现透明装饰模式时，要求具体装饰类的<code>operation()</code>方法覆盖抽象装饰类的<code>operation()</code>方法，除了调用原有对象的<code>operation()</code>外还需要调用新增的<code>addedBehavior()</code>方法来增加新行为</p><p>（2）半透明装饰模式<br>透明装饰模式的设计难度较大，而且有时我们需要单独调用新增的业务方法。为了能够调用到新增方法，我们不得不用具体装饰类型来定义装饰之后的对象，而具体构件类型还是可以使用抽象构件类型来定义，这种装饰模式即为半透明装饰模式，也就是说，对于客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的。如本节前面所提到的文件对象功能增加实例，为了能够调用到在<code>Approver</code>中新增方法<code>approve()</code>，客户端代码片段如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Document doc; <span class="hljs-comment">//使用抽象构件类型定义</span><br>doc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PurchaseRequest</span>();<br>Approver newDoc; <span class="hljs-comment">//使用具体装饰类型定义</span><br>newDoc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Approver</span>(doc);<br></code></pre></td></tr></table></figure><p>半透明装饰模式可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便；但是其最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。在实现半透明的装饰模式时，我们只需在具体装饰类中增加一个独立的<code>addedBehavior()</code>方法来封装相应的业务处理，由于客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用<code>addedBehavior()</code>方法来扩展系统功能。</p><p>装饰模式总结：</p><p>装饰模式降低了系统的耦合度，可以动态增加或删除对象的职责，并使得需要装饰的具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类。在软件开发中，装饰模式应用较为广泛，例如在<code>JavaIO</code>中的输入流和输出流的设计、<code>javax.swing</code>包中一些图形界面构件功能的增强等地方都运用了装饰模式。</p><ul><li>主要优点：<ol><li>对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。</li><li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。</li><li>可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。</li></ol></li><li>主要缺点：<ol><li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。</li><li>装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。</li></ol></li><li>适用场景：<ol><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（如<code>Java</code>语言中的<code>final</code>类）。</li></ol></li></ul><h2 id="外观模式（Facade-Pattern）"><a href="#外观模式（Facade-Pattern）" class="headerlink" title="外观模式（Facade Pattern）"></a>外观模式（Facade Pattern）</h2><p>定义：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p>外观模式结构图：</p><p><img src="https://i.loli.net/2021/10/01/2FCHWNmJ5YSn3ax.png" alt="外观模式结构图"></p><p>外观模式结构图里面有两个角色：</p><ol><li><code>Facade</code>（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</li><li><code>SubSystem</code>（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</li></ol><p>外观模式的典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemA</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">MethodA</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">// 业务实现代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemB</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">MethodB</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">// 业务实现代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubSystemC</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">MethodC</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">// 业务实现代码</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 在引入外观类之后，与子系统业务类之间的交互统一由外观类来完成，在外观类中通常存在如下代码：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemA</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemA</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemB</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemB</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SubSystemC</span> <span class="hljs-variable">obj3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubSystemC</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Method</span><span class="hljs-params">()</span><br>    &#123;<br>        obj1.MethodA();<br>        obj2.MethodB();<br>        obj3.MethodC();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 由于在外观类中维持了对子系统对象的引用，客户端可以通过外观类来间接调用子系统对象的业务方法，而无须与子系统对象直接交互。引入外观类后，客户端代码变得非常简单，典型代码如下：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Program</span><br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Main</span><span class="hljs-params">(string[] args)</span><br>    &#123;<br>        <span class="hljs-type">Facade</span> <span class="hljs-variable">facade</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Facade</span>();<br>        facade.Method();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在标准的外观模式结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入抽象外观类来对系统进行改进，在一定程度上可以解决该问题。</p><p>抽象外观类：<br>在引入抽象外观类之后，客户端可以针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改任何源代码并更换外观类的目的。</p><p>外观模式的总结：</p><ul><li>外观模式的优点：<ol><li>它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。</li><li>它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。</li><li>一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li></ol></li><li>外观模式的缺点：<ol><li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活 性。</li><li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。</li></ol></li><li>外观模式的适用场景：<ol><li>当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。</li><li>客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。</li><li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ol></li></ul><h2 id="享元模式（Flyweight-Pattern）"><a href="#享元模式（Flyweight-Pattern）" class="headerlink" title="享元模式（Flyweight Pattern）"></a>享元模式（Flyweight Pattern）</h2><p>定义：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</p><p>结构图（享元模式结构较为复杂，一般结合工厂模式一起使用，在它的结构图中包含了一个享元工厂类）：</p><p><img src="https://i.loli.net/2021/10/01/ZEKU8frBw7LMPab.png" alt="享元模式结构图"></p><p>在享元模式结构图中包含如下几个角色：</p><ul><li><code>Flyweight</code>（抽象享元类）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li><code>ConcreteFlyweight</code>（具体享元类）：它实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li><li><code>UnsharedConcreteFlyweight</code>（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li><li><code>FlyweightFactory</code>（享元工厂类）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在的话），返回新创建的实例并将其存储在享元池中。</li></ul><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在享元模式中引入了享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，当用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span> &#123;<br>    <span class="hljs-comment">//定义一个HashMap用于存储享元对象，实现享元池</span><br>    <span class="hljs-keyword">private</span> HashMap&lt;Flyweight&gt; flyweights = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> Flyweight <span class="hljs-title function_">getFlyweight</span><span class="hljs-params">(String key)</span>&#123;<br>        <span class="hljs-comment">//如果对象存在，则直接从享元池获取</span><br>        <span class="hljs-keyword">if</span>(flyweights.containsKey(key))&#123;<br>            <span class="hljs-keyword">return</span> flyweights.get(key);<br>        &#125;<br>        <span class="hljs-comment">//如果对象不存在，先创建一个新的对象添加到享元池中，然后返回</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Flyweight</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> newConcreteFlyweight();<br>            flyweights.put(key,fw);<br>            <span class="hljs-keyword">return</span> fw;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 享元类的设计是享元模式的要点之一，在享元类中要将内部状态和外部状态分开处理，通常将内部状态作为享元类的成员变量，而外部状态通过注入的方式添加到享元类中。典型的享元类代码如下所示：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyweight</span> &#123;<br>    <span class="hljs-comment">// 内部状态intrinsicState作为成员变量，同一个享元对象其内部状态是一致的</span><br>    <span class="hljs-keyword">private</span> String intrinsicState;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Flyweight</span><span class="hljs-params">(String intrinsicState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.intrinsicState=intrinsicState;<br>    &#125;<br>    <span class="hljs-comment">// 外部状态extrinsicState在使用时由外部设置，不保存在享元对象中，即使是同一个对象，在每一次调用时也可以传入不同的外部状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(String extrinsicState)</span> &#123;<br>        ......<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>标准的享元模式结构图中既包含可以共享的具体享元类，也包含不可以共享的非共享具体享元类。但是在实际使用过程中，我们有时候会用到两种特殊的享元模式：单纯享元模式和复合享元模式，下面将对这两种特殊的享元模式进行简单的介绍：</p><ol><li><p>单纯享元模式</p><p> 在单纯享元模式中，所有的具体享元类都是可以共享的，不存在非共享具体享元类。单纯享元模式的结构如图所示：</p><p> <img src="https://i.loli.net/2021/10/01/j6fNvAU9zOIumYC.png" alt="单纯享元模式"></p></li><li><p>复合享元模式</p><p> 将一些单纯享元对象使用组合模式加以组合，还可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。复合享元模式的结构如图所示：</p><p> <img src="https://i.loli.net/2021/10/01/1GVBALfl4tkTK5m.png" alt="复合享元模式"></p></li></ol><p>享元模式总结：</p><ul><li>主要优点：<ol><li>可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</li></ol></li><li>主要缺点：<ol><li>享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li><li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。</li></ol></li><li>适用场景：<ol><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ol></li></ul><h2 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h2><p>定义：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</p><p>代理模式的结构图：</p><p><img src="https://i.loli.net/2021/10/01/rZFl8X9HkAh2VgG.png" alt="代理模式结构图"></p><p>代理模式包含三个角色：</p><ol><li><code>Subject</code>（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</li><li><code>Proxy</code>（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。</li><li><code>RealSubject</code>（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</li></ol><p>典型代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象主题类声明了真实主题类和代理类的公共方法，它可以是接口、抽象类或具体类，客户端针对抽象主题类编程，一致性地对待真实主题和代理主题</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Request</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 真实主题类继承了抽象主题类，提供了业务方法的具体实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> override <span class="hljs-keyword">void</span> <span class="hljs-title function_">Request</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-comment">// 业务方法具体实现代码</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 代理类也是抽象主题类的子类，它维持一个对真实主题对象的引用，调用在真实主题中实现的业务方法，在调用时可以在原有业务方法的基础上附加一些新的方法来对功能进行扩充或约束</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subject</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">RealSubject</span> <span class="hljs-variable">realSubject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSubject</span>(); <span class="hljs-comment">// 维持一个对真实主题对象的引用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">PreRequest</span><span class="hljs-params">()</span><br>    &#123;<br>        ...<br>    &#125;<br>    <span class="hljs-keyword">public</span> override <span class="hljs-keyword">void</span> <span class="hljs-title function_">Request</span><span class="hljs-params">()</span><br>    &#123;<br>        PreRequest();<br>        realSubject.Request(); <span class="hljs-comment">// 调用真实主题对象的方法</span><br>        PostRequest();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">PostRequest</span><span class="hljs-params">()</span><br>    &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在实际开发过程中，代理类的实现比上述代码要复杂很多，代理模式根据其目的和实现方式不同可分为很多种类，其中常用的几种代理模式简要说明如下：</p><ol><li>远程代理（Remote Proxy）：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使（Ambassador）。</li><li>虚拟代理（Virtual Proxy）：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li>保护代理（Protect Proxy）：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li>缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li>智能引用代理（Smart Reference Proxy）：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。</li></ol><p>代理模式总结：</p><ul><li><p>主要优点：</p><ol><li>能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</li><li>客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。</li></ol><p>  不同类型的代理模式也具有独特的优点：</p><ol><li>远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。</li><li>虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。</li><li>缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。</li><li>保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。</li></ol></li><li><p>主要缺点：</p><ol><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。</li><li>实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。</li></ol></li><li><p>适用场景：</p><ol><li>当客户端对象需要访问远程主机中的对象时可以使用远程代理。</li><li>当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。</li><li>当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。</li><li>当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。</li><li>当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-创建型模式</title>
    <link href="/2021/09/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/09/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><h1 id="六个创建型模式"><a href="#六个创建型模式" class="headerlink" title="六个创建型模式"></a>六个创建型模式</h1><h2 id="简单工厂模式（Simple-Factory-Pattern）"><a href="#简单工厂模式（Simple-Factory-Pattern）" class="headerlink" title="简单工厂模式（Simple Factory Pattern）"></a>简单工厂模式（Simple Factory Pattern）</h2><p>定义：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态（static）方法，因此简单工厂模式又被称为静态工厂方法（<code>Static Factory Method</code>）模式，它属于类创建型模式。</p><p>简单工厂模式结构图：</p><p><img src="https://i.loli.net/2021/09/30/ahKtgoE5FG1pb6r.png" alt="简单工厂模式结构图"></p><p>在简单工厂模式结构图中有以下几个角色：</p><ol><li><code>Factory</code>（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法<code>actoryMethod()</code>，它的返回类型为抽象产品类型<code>Product</code>。</li><li><code>Product</code>（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</li><li><code>ConcreteProduct</code>（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在使用简单工厂模式时，首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现，典型的抽象产品类代码如下所示：</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-comment">// 所有产品类的公共业务方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodSame</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 公共方法的实现</span><br>    &#125;<br>    <span class="hljs-comment">// 声明抽象业务方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodDiff</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProduct</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-comment">// 实现业务方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodDiff</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 业务方法的实现</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象，典型的工厂类代码如下所示：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-comment">// 静态工厂方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Product <span class="hljs-title function_">getProduct</span><span class="hljs-params">(String arg)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (arg.equalsIgnoreCase(<span class="hljs-string">&quot;A&quot;</span>)) &#123;<br>            product = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProductA</span>();<br>            <span class="hljs-comment">// 初始化设置product</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arg.equalsIgnoreCase(<span class="hljs-string">&quot;B&quot;</span>)) &#123;<br>            product = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProductB</span>();<br>            <span class="hljs-comment">// 初始化设置product</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单工厂模式总结：</p><p>简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。</p><ul><li>主要优点：<ol><li>工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ol></li><li>主要缺点：<ol><li>由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ol></li><li>适用场景：<ol><li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</li></ol></li></ul><h2 id="工厂方法模式（Factory-Method-Pattern）"><a href="#工厂方法模式（Factory-Method-Pattern）" class="headerlink" title="工厂方法模式（Factory Method Pattern）"></a>工厂方法模式（Factory Method Pattern）</h2><p>定义：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式（<code>Factory Pattern</code>），又可称作虚拟构造器模式（<code>Virtual Constructor Pattern</code>）或多态工厂模式（<code>Polymorphic Factory Pattern</code>）。工厂方法模式是一种类创建型模式。</p><p>工厂方法模式结构图：</p><p><img src="https://i.loli.net/2021/09/30/mpX8u2E4b5t7efO.png" alt="工厂方法模式结构图"></p><p>在工厂方法模式结构图中包含以下几个角色：</p><ol><li><code>Product</code>（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。</li><li><code>ConcreteProduct</code>（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</li><li><code>Factory</code>（抽象工厂）：在抽象工厂类中，声明了工厂方法(<code>Factory Method</code>)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</li><li><code>ConcreteFactory</code>（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">factoryMethod</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 在抽象工厂中声明了工厂方法但并未实现工厂方法，具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时再指定具体工厂类，具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品，其典型代码如下所示：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">factoryMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProduct</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>工厂方法模式总结：</p><p>工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。</p><ul><li>主要优点：<ol><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ol></li><li>主要缺点：<ol><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li></ol></li><li>适用场景：<ol><li>客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。</li><li>抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li></ol></li></ul><h2 id="抽象工厂模式（Abstract-Factory-Pattern）"><a href="#抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="抽象工厂模式（Abstract Factory Pattern）"></a>抽象工厂模式（Abstract Factory Pattern）</h2><p>定义：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为<code>Kit模式</code>，它是一种对象创建型模式。</p><p>抽象工厂模式结构图：</p><p><img src="https://i.loli.net/2021/09/30/SIJkjQwDVv9g7xi.png" alt="抽象工厂模式结构图"></p><p>在抽象工厂模式中有以下几个角色：</p><ol><li><code>AbstractFactory</code>（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</li><li><code>ConcreteFactory</code>（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</li><li><code>AbstractProduct</code>（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</li><li><code>ConcreteProduct</code>（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractProductA <span class="hljs-title function_">createProductA</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 工厂方法一</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractProductB <span class="hljs-title function_">createProductB</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 工厂方法二</span><br>&#125;<br><span class="hljs-comment">// 具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。对于每一个具体工厂类，其典型代码如下所示：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-comment">// 工厂方法一</span><br>    <span class="hljs-keyword">public</span> AbstractProductA <span class="hljs-title function_">createProductA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProductA1</span>();<br>    &#125;<br>    <span class="hljs-comment">// 工厂方法二</span><br>    <span class="hljs-keyword">public</span> AbstractProductB <span class="hljs-title function_">createProductB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteProductB1</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象工厂模式总结：</p><p>抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中，例如在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。</p><ul><li>主要优点：<ol><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</li></ol></li><li>主要缺点：<ol><li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</li></ol></li><li>适用场景：<ol><li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</li><li>系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</li><li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。</li><li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li></ol></li></ul><h2 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h2><p>定义：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</p><p>单例模式结构图：</p><p><img src="https://i.loli.net/2021/09/30/mtTEWX1QdL9xRos.png" alt="单例模式结构图"></p><p>单例模式结构图中只有一个角色：</p><ol><li><code>Singleton</code>（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的<code>getInstance()</code>工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个<code>Singleton</code>类型的静态对象，作为外部共享的唯一实例。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 有两种常见的单例模式，一种是饿汉式单例模式，一种是懒汉式单例模式</span><br><span class="hljs-comment">// 1. 饿汉式单例模式典型代码：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EagerSingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">EagerSingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EagerSingleton</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">EagerSingleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EagerSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 2. 懒汉式单例模式典型代码：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LazySingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">LazySingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LazySingleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//第一重判断</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//锁定代码块</span><br>            <span class="hljs-keyword">synchronized</span> (LazySingleton.class) &#123;<br>                <span class="hljs-comment">//第二重判断</span><br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazySingleton</span>(); <span class="hljs-comment">//创建单例实例</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；懒汉式单例类线程安全控制烦琐，而且性能受影响。还有一种更好的方式是Initialization Demand Holder (IoDH)模式。</span><br><span class="hljs-comment">// 在IoDH中，我们在单例类中增加一个静态(static)内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用</span><br><span class="hljs-comment">//Initialization on Demand Holder</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HolderClass</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> HolderClass.instance;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        Singleton s1, s2;<br>        s1 = Singleton.getInstance();<br>        s2 = Singleton.getInstance();<br>        System.out.println(s1==s2);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）</span><br></code></pre></td></tr></table></figure><p>单例模式总结：</p><p>单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。</p><ul><li>主要优点：<ol><li>单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。</li></ol></li><li>主要缺点：<ol><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>现在很多面向对象语言（如Java、C#）的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。</li></ol></li><li>适用场景：<ol><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li></ol></li></ul><h2 id="原型模式（Prototype-Pattern）"><a href="#原型模式（Prototype-Pattern）" class="headerlink" title="原型模式（Prototype Pattern）"></a>原型模式（Prototype Pattern）</h2><p>定义：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。</p><p>原型模式结构图：</p><p><img src="https://i.loli.net/2021/09/30/6foy5JUZDwbEji7.png" alt="原型模式结构图"></p><p>在原型模式结构图中有以下几个角色：</p><ol><li><code>Prototype</code>（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。</li><li><code>ConcretePrototype</code>（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</li><li><code>Client</code>（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类<code>Prototype</code>编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原型模式的核心在于如何实现克隆方法，下面将介绍两种在Java语言中常用的克隆实现方法</span><br><span class="hljs-comment">// 1. 通用实现方法</span><br><span class="hljs-comment">// 通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，并将相关的参数传入新创建的对象中，保证它们的成员属性相同。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcretePrototype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Prototype</span><br>&#123;<br>    <span class="hljs-keyword">private</span> String attr; <span class="hljs-comment">// 成员属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAttr</span><span class="hljs-params">(String attr)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.attr = attr;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAttr</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.attr;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Prototype <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-comment">// 克隆方法</span><br>    &#123;<br>        <span class="hljs-type">Prototype</span> <span class="hljs-variable">prototype</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcretePrototype</span>(); <span class="hljs-comment">// 创建新对象</span><br>        prototype.setAttr(<span class="hljs-built_in">this</span>.attr);<br>        <span class="hljs-keyword">return</span> prototype;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 2. 使用Java提供的clone方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcretePrototype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Prototype <span class="hljs-title function_">clone</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            object = <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException exception) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Not support cloneable&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (Prototype )object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原型模式总结：</p><p>原型模式作为一种快速创建大量相同或相似对象的方式，在软件开发中应用较为广泛，很多软件提供的复制（<code>Ctrl + C</code>）和粘贴（<code>Ctrl + V</code>）操作就是原型模式的典型应用。</p><ul><li>主要优点：<ol><li>当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</li><li>扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</li><li>原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</li><li>可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。</li></ol></li><li>主要缺点：<ol><li>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</li><li>在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</li></ol></li><li>适用场景：<ol><li>创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。</li><li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</li><li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</li></ol></li></ul><h2 id="建造者模式（Builder-Pattern）"><a href="#建造者模式（Builder-Pattern）" class="headerlink" title="建造者模式（Builder Pattern）"></a>建造者模式（Builder Pattern）</h2><p>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</p><p>建造者模式结构图：</p><p><img src="https://i.loli.net/2021/09/30/TvbDQoye8ktEL3f.png" alt="建造者模式结构图"></p><p>在建造者模式结构图中有以下几个角色：</p><ol><li><code>Builder</code>（抽象建造者）：它为创建一个产品<code>Product</code>对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是<code>buildPartX()</code>，它们用于创建复杂对象的各个部件；另一类方法是<code>getResult()</code>，它们用于返回复杂对象。<code>Builder</code>既可以是抽象类，也可以是接口。</li><li><code>ConcreteBuilder</code>（具体建造者）：它实现了<code>Builder</code>接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</li><li><code>Product</code>（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</li><li><code>Director</code>（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其<code>construct()</code>建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者<code>Setter</code>方法将该对象传入指挥者类中。</li></ol><p>典型代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在建造者模式的定义中提到了复杂对象，那么什么是复杂对象？简单来说，复杂对象是指那些包含多个成员属性的对象，这些成员属性也称为部件或零件，如汽车包括方向盘、发动机、轮胎等部件，电子邮件包括发件人、收件人、主题、内容、附件等部件，一个典型的复杂对象类代码示例如下：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> String partA; <span class="hljs-comment">// 定义部件，部件可以是任意类型，包括值类型和引用类型</span><br>    <span class="hljs-keyword">private</span> String partB;<br>    <span class="hljs-keyword">private</span> String partC;<br>    <span class="hljs-comment">// partA的Getter方法和Setter方法省略</span><br>    <span class="hljs-comment">// partB的Getter方法和Setter方法省略</span><br>    <span class="hljs-comment">// partC的Getter方法和Setter方法省略</span><br>&#125;<br><span class="hljs-comment">// 在抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下：</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-comment">// 创建产品对象</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartA</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartB</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildPartC</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 返回产品对象</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 在建造者模式的结构中还引入了一个指挥者类Director，该类主要有两个作用：一方面它隔离了客户与创建过程；另一方面它控制产品的创建过程，包括某个buildPartX()方法是否被调用以及多个buildPartX()方法调用的先后次序等。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。在实际生活中也存在类似指挥者一样的角色，如一个客户去购买电脑，电脑销售人员相当于指挥者，只要客户确定电脑的类型，电脑销售人员可以通知电脑组装人员给客户组装一台电脑。指挥者类的代码示例如下：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span> &#123;<br>    <span class="hljs-keyword">private</span> Builder builder;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Director</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.builder = builder;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBuilder</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.builder = builer;<br>    &#125;<br>    <span class="hljs-comment">//产品构建与组装方法</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">construct</span><span class="hljs-params">()</span> &#123;<br>        builder.buildPartA();<br>        builder.buildPartB();<br>        builder.buildPartC();<br>        <span class="hljs-keyword">return</span> builder.getResult();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>建造者模式总结：</p><p>建造者模式的核心在于如何一步步构建一个包含多个组成部件的完整对象，使用相同的构建过程构建不同的产品，在软件开发中，如果我们需要创建复杂对象并希望系统具备很好的灵活性和可扩展性可以考虑使用建造者模式。</p><ul><li>主要优点：<ol><li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则”。</li><li>可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li></ol></li><li>主要缺点：<ol><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。</li></ol></li><li>适用场景：<ol><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署JavaWeb项目</title>
    <link href="/2021/07/10/%E9%83%A8%E7%BD%B2JavaWeb%E9%A1%B9%E7%9B%AE/"/>
    <url>/2021/07/10/%E9%83%A8%E7%BD%B2JavaWeb%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><blockquote><p>Author：RZIYang    2021年7月9日</p></blockquote><h1 id="项目名称"><a href="#项目名称" class="headerlink" title="项目名称"></a>项目名称</h1><p>《学生选课管理系统（StudentExaminationSystem）》（说实话不知道为什么取这个英文）</p><h1 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h1><ul><li><code>JDK 8</code>(1.8.291)</li><li><code>MySQL 8.0.25</code>  </li><li><code>Tomcat 9.0.48</code></li></ul><h1 id="需要上传到-Linux-上的文件"><a href="#需要上传到-Linux-上的文件" class="headerlink" title="需要上传到 Linux 上的文件"></a>需要上传到 Linux 上的文件</h1><p><img src="https://i.loli.net/2021/07/10/DcG4HE63xf72Muk.png" alt="image-20210709230401013"></p><h1 id="项目部署流程"><a href="#项目部署流程" class="headerlink" title="项目部署流程"></a>项目部署流程</h1><h2 id="打包项目为-war-包格式"><a href="#打包项目为-war-包格式" class="headerlink" title="打包项目为 war 包格式"></a>打包项目为 war 包格式</h2><ol><li>首先修改数据库的密码（因为 Linux 上设置的 MySQL 的密码和本地开发环境不一样）为：<code>Qf..2021</code></li><li>在 <code>Project Structure</code> 里面，选择 <code>Artifacts</code> ，点击 <code>&#39;+&#39;</code> ，并选择 <code>Web Application: Archive</code>。</li></ol><p><img src="https://i.loli.net/2021/07/10/cW7EUfXptgw1FIG.png" alt="image-20210709224400672"></p><ol start="3"><li>在右上角 <code>Tomcat 9.0.48</code> 的位置，打开下拉框，点击 <code>Edit Configurations...</code> ，然后再点击 <code>Deployment</code> ，点击 <code>‘+’</code> ，选择 <code>Artifact</code> ，然后点击 <code>OK</code> 。运行之后，在 <code>target</code> 文件夹里面就有 war 包了。</li></ol><p><img src="https://i.loli.net/2021/07/10/uYKoi2n9lkSeDbd.png" alt="image-20210709224852118"></p><p><img src="https://i.loli.net/2021/07/10/3BGWtdc7nai6I4D.png" alt="image-20210709224931566"></p><h2 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h2><ol><li>下载 rpm 文件，然后上传到虚拟机中。</li><li>输入命令：<code>rpm -ivh jdk-8u291-linux-x64.rpm</code></li></ol><p><img src="https://i.loli.net/2021/07/10/dBMc9v8WtIi7Qy6.png" alt="image-20210709142300113"></p><ol start="3"><li>配置环境变量，输入 <code>vi /etc/profile</code> ，添加以下行，然后输入 <code>source /etc/profile</code></li></ol><p><img src="https://i.loli.net/2021/07/10/YxFb7BhpURwyLMf.png" alt="image-20210709225451987"></p><ol start="4"><li>安装完之后，输入 <code>java -version</code> 命令和 <code>javac -version</code> 命令检测安装是否完成。</li></ol><p><img src="https://i.loli.net/2021/07/10/Ai8GhKIPvQSrLf7.png" alt="image-20210709142449645"></p><ol start="5"><li>出现以上内容即为 JDK 安装完成。</li></ol><h2 id="安装-MySQL-服务"><a href="#安装-MySQL-服务" class="headerlink" title="安装 MySQL 服务"></a>安装 MySQL 服务</h2><ol><li>下载 MySQL 8.0 的 rpm 文件并上传到 Linux 上。</li><li>输入命令：<code>rpm -ivh mysql80-community-release-el7-3.noarch.rpm</code></li></ol><p><img src="https://i.loli.net/2021/07/10/4gdWpb1rZPoQi8n.png" alt="image-20210709143119408"></p><ol start="3"><li>输入命令：<code>ls /etc/yum.repos.d/</code> 检测是否成功下载源配置文件。</li></ol><p><img src="https://i.loli.net/2021/07/10/NAkrKuCBj7xLGdT.png" alt="image-20210709143352049"></p><ol start="4"><li>输入命令： <code>vi /etc/yum.repos.d/mysql-community.repo</code> 修改源配置文件，检查 <code>[mysql80-community]</code> 标签后的 <code>enabled</code> 值是不是<code>1</code>，若不是，则修改为<code>1</code>。</li></ol><p><img src="https://i.loli.net/2021/07/10/OCKTA1jS8LPbHyM.png" alt="image-20210709143629018"></p><p><img src="https://i.loli.net/2021/07/10/sRyMwqJ8Iri97BH.png" alt="image-20210709143644335"></p><ol start="5"><li>输入命令：<code>yum repolist</code> 检测 yum 仓库列表是否有 <code>mysql80-community</code> 。</li></ol><p><img src="https://i.loli.net/2021/07/10/Ui4m13QAeHEDOTo.png" alt="image-20210709144146615"></p><ol start="6"><li>然后安装 MySQL ，输入命令： <code>yum install mysql-community-server -y</code> ，等待安装完成。</li></ol><p><img src="https://i.loli.net/2021/07/10/oF7QSrsRWEw5nTq.png" alt="image-20210709153808350"></p><ol start="7"><li><p>然后输入命令，启动 <code>mysqld</code> 服务：<code>systemctl start mysqld</code></p></li><li><p>通过 grep 命令获取初始密码：<code>grep password /var/log/mysqld.log</code></p></li></ol><p><img src="https://i.loli.net/2021/07/10/Wk8BVI5KQovNUX6.png" alt="image-20210709154054502"></p><ol start="9"><li>然后通过以下命令修改密码：<code>mysqladmin -uroot -p&#39;Ee;5NujWkp4g&#39; password &#39;Qf..2021&#39;</code></li></ol><p><img src="https://i.loli.net/2021/07/10/zeypodhQ8ug4Hf6.png" alt="image-20210709154236761"></p><ol start="10"><li>测试是否安装完成，输入命令 <code>mysql -uroot -p&#39;Qf..2021&#39;</code> 登录进入 MySQL。</li></ol><p><img src="https://i.loli.net/2021/07/10/ODCMiu9ebQmYkPr.png" alt="image-20210709154446081"></p><h2 id="创建数据库，并导入-SQL-数据"><a href="#创建数据库，并导入-SQL-数据" class="headerlink" title="创建数据库，并导入 SQL 数据"></a>创建数据库，并导入 SQL 数据</h2><ol><li>登录 MySQL ，使用 <code>source Examination_System.sql;</code> 命令导入数据库</li></ol><p><img src="https://i.loli.net/2021/07/10/KXof2F6Yc1BDgqQ.png" alt="image-20210709155027963"></p><ol start="2"><li>使用 <code>show databases;</code> 和 <code>show tables;</code> 命令检测是否导入成功。</li></ol><p><img src="https://i.loli.net/2021/07/10/SGkDKvXpce5xEoN.png" alt="image-20210709155407359"></p><h2 id="安装-Tomcat"><a href="#安装-Tomcat" class="headerlink" title="安装 Tomcat"></a>安装 Tomcat</h2><ol><li><p>将 Tomcat 的 tar.gz 压缩包解压到 <code>/usr/local</code> 文件夹内，输入的命令是：<code>tar -xf apache-tomcat-9.0.48.tar.gz -C /usr/local</code> </p></li><li><p>使用 mv 命令将文件夹重命名：<code>mv apache-tomcat-9.0.48/ tomcat/</code></p></li></ol><p><img src="https://i.loli.net/2021/07/10/OtN96MsfamHQ1Gg.png" alt="image-20210709160159288"></p><ol start="3"><li>修改环境变量：<code>vi /etc/profile</code>  ，然后添加以下几行：</li></ol><p><img src="https://i.loli.net/2021/07/10/ARsYcyxdpqEZGiM.png" alt="image-20210709160521056"></p><ol start="4"><li><p>输入 <code>source /etc/profile</code> 命令，让添加的代码起作用。</p></li><li><p>启动 Tomcat ，输入命令： <code>/usr/local/tomcat/bin/startup.sh</code></p></li></ol><p><img src="https://i.loli.net/2021/07/10/QzV5LiBZDw6WIaA.png" alt="image-20210709225349732"></p><ol start="6"><li>在浏览器访问 <a href="http://192.168.56.129:8080/">http://192.168.56.129:8080</a> 测试 Tomcat 是否成功启动（先使用 <code>systemctl stop firewalld</code> 命令关闭防火墙）。</li></ol><p><img src="https://i.loli.net/2021/07/10/Gd23AZeJBmiLtXl.png" alt="image-20210709161604395"></p><h2 id="将项目的-war-包部署到-Tomcat-上"><a href="#将项目的-war-包部署到-Tomcat-上" class="headerlink" title="将项目的 war 包部署到 Tomcat 上"></a>将项目的 war 包部署到 Tomcat 上</h2><ol><li><p>将 war 包放到 Tomcat 根目录的 <code>webapps</code> 文件夹内，使用命令：<code>mv Examination_System.war /usr/local/tomcat/webapps</code></p></li><li><p>修改 Tomcat 根目录下，<code>conf</code> 文件夹内的 <code>server.xml</code> 文件，使用命令：<code>vi /usr/local/tomcat/conf/server.xml</code> ，然后再在 <code>&lt;Host&gt;</code> 标签内添加以下内容： <code>&lt;Context path=&quot;&quot; docBase=&quot;Examination_System&quot; debug=&quot;0&quot; reloadable=&quot;true&quot;&gt;&lt;/Context&gt;</code></p></li></ol><p><img src="https://i.loli.net/2021/07/10/seUJgq8Nytv7MpC.png" alt="image-20210709225133833"></p><ol start="3"><li>使用命令：<code>/usr/local/tomcat/bin/shutdown.sh</code> 关闭 Tomcat 然后再启动 Tomcat ，再访问网址：<a href="http://192.168.56.129:8080/">http://192.168.56.129:8080</a> 测试项目是否部署成功。</li></ol><p><img src="https://i.loli.net/2021/07/10/pT6w9WlhUfg5Yn3.png" alt="image-20210709225326237"></p><p><img src="https://i.loli.net/2021/07/10/HP8tMOUSvXNlcqh.png" alt="image-20210709225821558"></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Problem#36 题解</title>
    <link href="/2021/04/25/LeetCode-Problem-36-%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/04/25/LeetCode-Problem-36-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><p><a href="https://leetcode.com/problems/valid-sudoku/">题目传送门</a></p><p>题意：就是类似于数独游戏，给你一个 <code>9x9</code> 的数组，数组元素由数字 <code>1-9</code> 和句号 <code>.</code> 组成，判断给你的数组是否满足要求（1. 每一行给出的数字不能重复。2. 每一列给出的数字不能重复。3. <code>9</code> 个 <code>3x3</code> 的格子里面给出的数字不能重复。），然后给出 <code>true</code> 或 <code>false</code> 。</p><p>先给出我的 AC 代码，然后再将思路。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> a[<span class="hljs-number">9</span>], b[<span class="hljs-number">9</span>], c[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];    <span class="hljs-comment">// 分别代表行、列和 3*3 的格子</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>        &#123;<br>            a[i] = b[i] = c[i / <span class="hljs-number">3</span>][i % <span class="hljs-number">3</span>] = <span class="hljs-number">0x01ff</span>; <span class="hljs-comment">// 初始化为 0000 0001 1111 1111B，最右边9位为1代表该数字没有出现过，0代表出现过</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-comment">// 如果该字符是句号就跳过</span><br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> num = board[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>;    <span class="hljs-comment">// 字符转换为数字</span><br>                num = <span class="hljs-number">1</span> &lt;&lt; (num - <span class="hljs-number">1</span>);   <span class="hljs-comment">// 进行左移操作</span><br>                <span class="hljs-keyword">if</span> ((a[i] &amp; num) &amp;&amp; (b[j] &amp; num) &amp;&amp; (c[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>] &amp; num))    <span class="hljs-comment">// 这里的 与 操作用于判断该数字是否出现过，即该 位 数字是否为1</span><br>                &#123;<br>                    a[i] ^= num; <span class="hljs-comment">// 这里 异或 操作用于将该 位 数字从1变为0，其他位置不变，也可以用 -= </span><br>                    b[j] ^= num;<br>                    c[i / <span class="hljs-number">3</span>][j / <span class="hljs-number">3</span>] ^= num;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路：这题我的解法用到了位操作，将 <code>9</code> 行、 <code>9</code> 列和每一个 <code>3*3</code> 的格子分别用两个一维数组和一个二维数组来表示，然后用这几个数组记录每一行、列和 <code>3*3</code> 的格子里面的数字是否出现过。这里用第<code>0</code>行来举例：</p><p><strong>假设第0行，第0列的数字为1，然后1左移0位，得到0000 0000 0000 0001B,然后将其和a[0]（0000 0001 1111 1111B）进行异或操作，得到 0000 0001 1111 1110B，再假设第0行第1列数字依旧为1，那么将该数字和a[0]（0000 0001 1111 1110B）进行与操作，得到0（即false），然后就不会进入if语句内部，直接返回false。</strong></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Problem#25 题解</title>
    <link href="/2021/03/10/LeetCode-Problem-25-%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/03/10/LeetCode-Problem-25-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><p><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">题目传送门</a></p><p>题意：给定一个链表和一个整数 k ，让链表每隔 k 个节点就反转一次，如果剩下的节点个数不足 k 个，就不进行反转，将反转后的链表首部返回。</p><p>思路：这题和之前的反转相邻两个节点的区别就是，这题的反转的节点的个数是不确定的。这里因为反转之后的节点有可能无法通过链表的 next 访问到或者通过 next 访问的步骤太复杂了，所以我想法是用一个 ListNode 指针数组来存储链表的所有节点，然后再进行访问并反转就比较简单了。假设某链表有 n 组 k 个节点，这里将这 n 组节点分为两部分来考虑，第一部分是前 n - 1 组节点，第二部分是第 n 组节点，前面的 n - 1 组节点都是同样的思路。</p><p>这里用 head &#x3D; [1, 2, 3, 4, 5, 6, 7, 8]   k &#x3D; 3 来举例，对于前面 n - 1 组，即 head[1] 、 head[2] 和 head[3] （这里用 head[n] 代表链表的第 n 个节点），我的思路如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">head[<span class="hljs-number">1</span>]-&gt;next = head[<span class="hljs-number">6</span>];<span class="hljs-comment">// 这里将 head[1] 和下一组反转后的第一个节点（即 head[6]）连接起来</span><br>head[<span class="hljs-number">2</span>]-&gt;next = head[<span class="hljs-number">1</span>];<span class="hljs-comment">// 接下来就是将剩下的节点与它的前一个节点连接起来就够了</span><br>head[<span class="hljs-number">3</span>]-&gt;next = head[<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>对于第 n 组，即 head[4] 、 head[5] 和 head[6] ，则基本上相同，只有第一个节点不同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">head[<span class="hljs-number">4</span>]-&gt;next = head[<span class="hljs-number">7</span>];<span class="hljs-comment">// 这里由于后面剩下的节点不足 3 个，所以剩下的节点不需要进行反转，需要注意的是：如果剩下的节点数正好为 0，那么就需要特判，将 head[4] 的 next 设置为 nullptr,不然可能会数组访问越界造成 Runtime Error</span><br>head[<span class="hljs-number">5</span>]-&gt;next = head[<span class="hljs-number">4</span>];<br>head[<span class="hljs-number">6</span>]-&gt;next = head[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *arr[<span class="hljs-number">5001</span>];<br>        <span class="hljs-type">int</span> arrSize = <span class="hljs-number">0</span>;<br>        ListNode *p = head;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            arr[arrSize] = p;<br>            arrSize++;<br>            p = p-&gt;next;<br>        &#125;<br>        ListNode *res = <span class="hljs-literal">nullptr</span>;<br>        res = arr[k - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (arrSize / k) * k; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i % k == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i / k != arrSize / k - <span class="hljs-number">1</span>)<br>                &#123;<br>                    arr[i]-&gt;next = arr[i + <span class="hljs-number">2</span> * k - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (i + k &lt; arrSize)<br>                    &#123;<br>                        arr[i]-&gt;next = arr[i + k];<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        arr[i]-&gt;next = <span class="hljs-literal">nullptr</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                arr[i]-&gt;next = arr[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Problem#24 题解</title>
    <link href="/2021/03/08/LeetCode-Problem-24-%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/03/08/LeetCode-Problem-24-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/">题目传送门</a></p><p>题意：给定一个链表，交换链表中相邻的两个节点，返回头节点。</p><p>思路：有两种方法，一种是将相邻两个节点的值交换。一种是不修改值，仅修改节点的 next 值。显然，第一种较为简单，第二种较难。这里我用的是第二种。首先，将链表分为两部分进行处理，一部分是头部的两个节点，另一部分是链表的其他节点。<strong>这里为了表述方便，我用 head[1] 代表链表的头节点， head[2] 代表第二个节点，以此类推， head[n] 代表第 n 个节点。</strong></p><p>对头部两个节点的处理，就是直接经过以下处理就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">ListNode* tmp = head[<span class="hljs-number">2</span>];<br>head[<span class="hljs-number">1</span>]-&gt;next = head[<span class="hljs-number">1</span>]-&gt;next-&gt;next;<br>tmp-&gt;next = head[<span class="hljs-number">1</span>];<span class="hljs-comment">// 这里由于 head[1] 的 next 变了，无法直接访问到 head[2] ，需要提前将 head[2] 存到一个临时指针变量中</span><br>res = tmp;<span class="hljs-comment">// res 为新的头节点，用于将结果返回</span><br></code></pre></td></tr></table></figure><p>对于其他部分的节点，<strong>这里为了方便，我用 head[3] 和 head[4] 的交换来进行举例</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* p = head[<span class="hljs-number">2</span>];<span class="hljs-comment">// 这里将 head[2] 存起来是为了通过 head[2] 来访问 head[3] 和 head[4]，之所以不直接用 head[3]，是因为如果用 head[3] 就无法将交换之后的 head[4] 和之前的 head[2] 连接起来</span><br>ListNode* tmp = head[<span class="hljs-number">4</span>];<span class="hljs-comment">// 将 head[5] 存储起来，原因类似于上面的 head[2]</span><br>p-&gt;next-&gt;next = p-&gt;next-&gt;next-&gt;next;<span class="hljs-comment">// 等同于 head[3]-&gt;next = head[5]</span><br>tmp-&gt;next = p-&gt;next;<span class="hljs-comment">// 等同于 head[4]-&gt;next = head[3]</span><br>p-&gt;next = tmp;<span class="hljs-comment">//等同于 head[2]-&gt;next = head[4]</span><br></code></pre></td></tr></table></figure><p>上面就是大致的思路了。接下来是 AC 的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *res = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            res = head;<br>            <span class="hljs-keyword">if</span> (head-&gt;next != <span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                ListNode *t = head-&gt;next;<br>                head-&gt;next = head-&gt;next-&gt;next;<br>                t-&gt;next = head;<br>                res = t;<br>                head = t-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span> &amp;&amp; head-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; head-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            ListNode *t = head-&gt;next-&gt;next;<br>            head-&gt;next-&gt;next = head-&gt;next-&gt;next-&gt;next;<br>            t-&gt;next = head-&gt;next;<br>            head-&gt;next = t;<br>            head = t-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Problem#15 题解</title>
    <link href="/2021/03/05/LeetCode-Problem-15-%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/03/05/LeetCode-Problem-15-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><p><a href="https://leetcode.com/problems/3sum/">题目传送</a></p><p>题目概述：给出一个数组，在该数组中寻找若干组三个数字相加和为 0 的组合，且这三个数字不能全部相同。</p><p>思路：由输出样例可以看出，结果是由小到大排序了的，且没有重复的组合。所以我一开始的思路是将数组进行排序。然后去重，将三个或以上的重复数字删减为两个。最后再通过固定一个数字，采用双指针法得出结果。最终由于花了太长时间没有将代码实现出来，我就看了 <code>Discuss</code> 里面别人的解题思路，发现别人没有去重的操作，而是通过在双指针法得出 <code>nums[i] + nums[left] + nums[right] == 0</code> 之后，判断 left 的右边的数字是否和 left 的数字相同来达到去重的效果， right 同理。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)<br>    &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br><br>        <span class="hljs-comment">// 由于输出结果排好了序，所以需要进行排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> vecSize = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 接下来将一个值固定，然后对其它值使用双指针法判断</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vecSize - <span class="hljs-number">2</span>; i++)<br>        &#123;<br>            <span class="hljs-comment">// 判断固定的数字是否重复，如果重复就直接跳过</span><br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = vecSize - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right)<br>            &#123;<br>                <span class="hljs-type">int</span> sum = nums[i] + nums[left] + nums[right];<br>                <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>)<br>                &#123;<br>                    vector&lt;<span class="hljs-type">int</span>&gt; t = &#123;nums[i], nums[left], nums[right]&#125;;<br>                    res.<span class="hljs-built_in">push_back</span>(t);<br>                    <span class="hljs-comment">// 这里对 left 后面的数字进行去重</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])<br>                        left++;<br>                    <span class="hljs-comment">// 这里对 right 前面的数字进行去重</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])<br>                        right--;<br>                    left++;<br>                    right--;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    left++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Two Pointers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[Java]基于k-means算法的图像分割</title>
    <link href="/2020/12/18/Java-%E5%9F%BA%E4%BA%8Ek-means%E7%AE%97%E6%B3%95%E7%9A%84%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    <url>/2020/12/18/Java-%E5%9F%BA%E4%BA%8Ek-means%E7%AE%97%E6%B3%95%E7%9A%84%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><p>文章的开头先介绍一下 k-means 算法：</p><blockquote><p>输入：</p><p>​            k：簇的数目</p><p>​            D：包含n个对象的数据集。</p><p>输出：    k个簇的集合</p><p>步骤：</p><p>​    （1）从D中任意选择k个对象最为初始簇中心。</p><p>​    （2）根据簇中对象的均值，将每个对象分配到最相似的簇。</p><p>​    （3）更新簇均值，即重新计算每个簇中对象的均值。</p><p>​    （4）重复步骤（2）和步骤（3）直到簇均值不再变化。        </p></blockquote><p>​        我这里使用的是基于聚类的图像分割，k-means算法是进行基于聚类的图像分割的经典算法，这个算法有在使用时有一些缺陷：</p><p>​        （1）结果容易被初始簇中心的选择所影响，容易陷入局部最优。</p><p>​        （2）聚类的效果非常依赖于k值的选择。k值过小，分割效果不明显。k值过大，图像的细节会过于明显。</p><p>​        由于能力有限，我写的k-means算法的优化的方面主要有两个：</p><p>​        （1）初始簇中心的选择，通过将图片像素灰度化（将RGB值按3:6:1计算得出），按照灰度值排序，然后将数据集k等分，取每个等分的平均值（灰度值）作为簇类中心的值（灰度值，R&#x3D;G&#x3D;B&#x3D;灰度值）。</p><p>​        （2）使用拐点法和平均轮廓系数法，根据程序运行输出的误差平方和（SSE）和平均轮廓系数，绘制折线图，然后根据折线图确认k值。</p><p>代码：</p><ol><li>dataItem.java</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bigData;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dataItem</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> r;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> g;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> grayScale;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> group;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sortDataItem</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;sortDataItem&gt; &#123;<br>    <span class="hljs-keyword">public</span> dataItem di;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> width;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> height;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">sortDataItem</span><span class="hljs-params">()</span> &#123;<br>        di = <span class="hljs-keyword">new</span> <span class="hljs-title class_">dataItem</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(sortDataItem s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.di.grayScale != s.di.grayScale) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.di.grayScale &lt; s.di.grayScale ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>ImageCluster.java</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bigData;<br><br><span class="hljs-keyword">import</span> java.awt.Color;<br><span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> javax.imageio.ImageIO;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageCluster</span> &#123;<br>    <span class="hljs-comment">//主要功能就是读取一副图像，再对图像进行分割</span><br>    <span class="hljs-comment">//需要分类的簇数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> k;<br>    <span class="hljs-comment">//迭代次数</span><br>    <span class="hljs-comment">//private int m;</span><br>    <span class="hljs-comment">//数据集合</span><br>    <span class="hljs-keyword">private</span> dataItem[][] source;<br>    <span class="hljs-comment">//簇类中心集合</span><br>    <span class="hljs-keyword">private</span> dataItem[] center;<br>    <span class="hljs-comment">//统计每个簇的像素点的总和，用于计算新的簇类中心</span><br>    <span class="hljs-keyword">private</span> dataItem[] centerSum;<br>    <span class="hljs-comment">// 图片的宽高</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> width;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> height;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        center = <span class="hljs-literal">null</span>;<br>        centerSum = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//读取指定目录的图片数据，并且写入数组，这个数据要继续处理</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] getImageData(String path) &#123;<br>        <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">bi</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            bi = ImageIO.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path));<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        width = bi.getWidth();<br>        height = bi.getHeight();<br>        <span class="hljs-type">int</span>[][] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[width][height];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; width; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; height; j++)<br>                data[i][j] = bi.getRGB(i, j);<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-comment">//用来得到灰度值，使用加权平均法，rgb取3:6:1</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getGrayScale</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> g, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> (r * <span class="hljs-number">3</span> + g * <span class="hljs-number">6</span> + b) / <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//用来处理获取的像素数据，将整型数组的值转化为RGB值，存储进dataItem类型的二维数组中，返回二维数组</span><br>    <span class="hljs-keyword">private</span> dataItem[][] InitData(<span class="hljs-type">int</span>[][] data) &#123;<br>        dataItem[][] dataitems = <span class="hljs-keyword">new</span> <span class="hljs-title class_">dataItem</span>[data.length][data[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; data.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; data[<span class="hljs-number">0</span>].length; j++) &#123;<br>                <span class="hljs-type">dataItem</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dataItem</span>();<br>                <span class="hljs-type">Color</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(data[i][j]);<br><br>                di.r = c.getRed();<br>                di.g = c.getGreen();<br>                di.b = c.getBlue();<br>                di.grayScale = getGrayScale(di.r, di.g, di.b);<br>                di.group = <span class="hljs-number">1</span>;<br>                dataitems[i][j] = di;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dataitems;<br>    &#125;<br><br>    <span class="hljs-comment">//将排好序的数据k等分然后返回各个等分的平均数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAverage</span><span class="hljs-params">(sortDataItem[] s, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> s.length / k * t;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> s.length / k * (t + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> begin; i &lt; end; i++) &#123;<br>            sum += s[i].di.grayScale;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum / (s.length / k);<br>    &#125;<br><br>    <span class="hljs-comment">//生成初始中心,初始化中心通过将像素点按照灰度值排序，然后k等分，在等分后的各个部分中取像素的平均数作为每个聚类初始中心</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initCenters</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>        center = <span class="hljs-keyword">new</span> <span class="hljs-title class_">dataItem</span>[k];<br>        centerSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">dataItem</span>[k];<span class="hljs-comment">//用来统计每个聚类里面的RGB分别之和，方便计算均值</span><br>        <span class="hljs-comment">//初始化sortDI</span><br>        sortDataItem[] sortDI = <span class="hljs-keyword">new</span> <span class="hljs-title class_">sortDataItem</span>[width * height];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; sortDI.length; i++) &#123;<br>            sortDI[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">sortDataItem</span>();<br>        &#125;<br>        <span class="hljs-comment">//将数据存储进sortDI中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; width; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; height; j++) &#123;<br>                sortDI[i * height + j].di = source[i][j];<br>                sortDI[i * height + j].width = i;<br>                sortDI[i * height + j].height = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//排序</span><br>        Arrays.sort(sortDI, sortDataItem::compareTo);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-type">dataItem</span> <span class="hljs-variable">cent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dataItem</span>();<br>            <span class="hljs-type">dataItem</span> <span class="hljs-variable">cent2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dataItem</span>();<br><br>            cent.group = i;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">gs</span> <span class="hljs-operator">=</span> getAverage(sortDI, i);<br>            cent.r = gs;<br>            cent.g = gs;<br>            cent.b = gs;<br>            cent.grayScale = gs;<br>            center[i] = cent;<br><br>            cent2.r = <span class="hljs-number">0</span>;<br>            cent2.g = <span class="hljs-number">0</span>;<br>            cent2.b = <span class="hljs-number">0</span>;<br>            cent2.grayScale = <span class="hljs-number">0</span>;<br>            cent2.group = <span class="hljs-number">0</span>;<br>            centerSum[i] = cent2;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//计算两个像素之间的RGB的欧几里得距离</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">distance</span><span class="hljs-params">(dataItem first, dataItem second)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.sqrt((first.r - second.r) * (first.r - second.r) +<br>                (first.g - second.g) * (first.g - second.g) +<br>                (first.b - second.b) * (first.b - second.b));<br>    &#125;<br><br>    <span class="hljs-comment">//返回一个数组中最小的坐标</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(<span class="hljs-type">double</span>[] distance)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">minDistance</span> <span class="hljs-operator">=</span> distance[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minLocation</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; distance.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (distance[i] &lt; minDistance) &#123;<br>                minDistance = distance[i];<br>                minLocation = i;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (distance[i] == minDistance) &#123;<br>                <span class="hljs-keyword">if</span> ((Math.random() * <span class="hljs-number">10</span>) &lt; <span class="hljs-number">5</span>) &#123;<br>                    minLocation = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minLocation;<br>    &#125;<br><br>    <span class="hljs-comment">// 每个点进行分类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clusterSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">double</span> distance[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; width; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; height; j++) &#123;<br>                <span class="hljs-comment">//求出距离中心点最短的中心</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; q &lt; k; q++) &#123;<br>                    distance[q] = distance(center[q], source[i][j]);<br>                &#125;<br>                group = minDistance(distance);<span class="hljs-comment">//寻找该点最近的中心</span><br>                source[i][j].group = group;<span class="hljs-comment">//把该点进行分类</span><br><br>                centerSum[group].r += source[i][j].r;<br>                centerSum[group].g += source[i][j].g;<br>                centerSum[group].b += source[i][j].b;<br>                <span class="hljs-comment">//centerSum[group].grayScale += source[i][j].grayScale;</span><br>                centerSum[group].group += <span class="hljs-number">1</span>;<span class="hljs-comment">//这个就是用来统计聚类里有几个点</span><br>                group = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//设置新的中心</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNewCenter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-comment">//取平均值为新的中心</span><br>            center[i].r = (<span class="hljs-type">int</span>) (centerSum[i].r / centerSum[i].group);<br>            center[i].g = (<span class="hljs-type">int</span>) (centerSum[i].g / centerSum[i].group);<br>            center[i].b = (<span class="hljs-type">int</span>) (centerSum[i].b / centerSum[i].group);<br>            center[i].grayScale = getGrayScale(center[i].r, center[i].g, center[i].b);<br>            center[i].group = i;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//输出聚类好的数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ImagedataOut</span><span class="hljs-params">(String path)</span> &#123;<br>        Color[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>[k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            c[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>((i + <span class="hljs-number">1</span>) * (<span class="hljs-number">255</span> / (k + <span class="hljs-number">1</span>)),<br>                    (i + <span class="hljs-number">1</span>) * (<span class="hljs-number">255</span> / (k + <span class="hljs-number">1</span>)),<br>                    (i + <span class="hljs-number">1</span>) * (<span class="hljs-number">255</span> / (k + <span class="hljs-number">1</span>)));<br>        &#125;<br><br>        <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">nbi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedImage</span>(width, height, BufferedImage.TYPE_INT_RGB);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; width; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; height; j++) &#123;<br>                nbi.setRGB(i, j, c[source[i][j].group].getRGB());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ImageIO.write(nbi, <span class="hljs-string">&quot;jpg&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//进行kmeans计算的核心函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">kmeans</span><span class="hljs-params">(String inPath, <span class="hljs-type">int</span> maxK, <span class="hljs-type">int</span> maxM)</span> &#123;<br>        source = InitData(getImageData(inPath));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">outPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;images\\out&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; t &lt;= maxK; t++) &#123;<br>            init();<br>            k = t;<br>            <span class="hljs-comment">//初始化聚类中心</span><br>            initCenters(k);<br>            <span class="hljs-comment">//进行最多maxM次聚类</span><br>            <span class="hljs-type">int</span> m;<br>            <span class="hljs-keyword">for</span> (m = <span class="hljs-number">0</span>; m &lt; maxM; m++) &#123;<br>                <span class="hljs-comment">// 将每个点进行分类</span><br>                clusterSet();<br>                <span class="hljs-comment">// 临时存储簇类中心的灰度值，用于后续判断灰度值是否改变</span><br>                <span class="hljs-type">int</span>[] oldCenter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>                    oldCenter[i] = center[i].grayScale;<br>                &#125;<br>                <span class="hljs-comment">// 设置新的簇类中心</span><br>                setNewCenter();<br>                <span class="hljs-comment">// 判断旧的簇类中心和新的簇类中心是否相等，如果相等，说明再进行迭代就没有效果了</span><br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>                    <span class="hljs-keyword">if</span> (oldCenter[i] != center[i].grayScale) &#123;<br>                        flag = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//重置之前的求和结果</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>                    centerSum[i].r = <span class="hljs-number">0</span>;<br>                    centerSum[i].g = <span class="hljs-number">0</span>;<br>                    centerSum[i].b = <span class="hljs-number">0</span>;<br>                    centerSum[i].grayScale = <span class="hljs-number">0</span>;<br>                    centerSum[i].group = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//当k值不同时输出不同的误差平方和，然后使用肘部法则判断取哪个k值</span><br>            <span class="hljs-type">double</span> <span class="hljs-variable">SSE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            SSE = computeSSE();<br>            <span class="hljs-comment">//计算平均轮廓系数</span><br>            <span class="hljs-type">double</span> <span class="hljs-variable">avgSC</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            avgSC = computeAverageSilhouetteCoefficient();<br>            <span class="hljs-comment">//输出不同k值对应的迭代次数、误差平方和、平均轮廓系数</span><br>            System.out.println(<span class="hljs-string">&quot;k = &quot;</span> + k +<br>                    <span class="hljs-string">&quot;, 迭代总次数：&quot;</span> + m +<br>                    <span class="hljs-string">&quot;, 误差平方和（除以像素总数）：&quot;</span> + String.format(<span class="hljs-string">&quot;%.2f&quot;</span>, SSE / (width * height)) +<br>                    <span class="hljs-string">&quot;, 平均轮廓系数：&quot;</span> + String.format(<span class="hljs-string">&quot;%.2f&quot;</span>, avgSC)<br>            );<br>            <span class="hljs-comment">//当k值不同时，输出不同k值对应的图片</span><br>            ImagedataOut(outPath + k + <span class="hljs-string">&quot;.jpg&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算误差平方和（SSE）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">computeSSE</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">SSE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; width; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; height; j++) &#123;<br>                <span class="hljs-type">double</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> distance(source[i][j], center[source[i][j].group]);<br>                SSE += dis * dis;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> SSE;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算轮廓系数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">computeSilhouetteCoefficient</span><span class="hljs-params">(dataItem di, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-comment">//计算di这个点的ao值</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">ao</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//计算di这个点的bo值</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">bo</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">double</span>[] dis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[k];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; width; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; height; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i != x &amp;&amp; i != y) &#123;<br>                    <span class="hljs-keyword">if</span> (source[i][j].group == di.group) &#123;<br>                        ao += distance(di, source[i][j]);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (source[i][j].group != di.group) &#123;<br>                        dis[source[i][j].group] += distance(di, source[i][j]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        ao /= centerSum[di.group].group - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        for (int i = 0; i &lt; width; i++) &#123;</span><br><span class="hljs-comment">            for (int j = 0; j &lt; height; j++) &#123;</span><br><span class="hljs-comment">                    if (source[i][j].group != di.group) &#123;</span><br><span class="hljs-comment">                        dis[source[i][j].group] += distance(di, source[i][j]);</span><br><span class="hljs-comment">                    &#125;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">         */</span><br>        bo = Double.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i != di.group) &#123;<br>                dis[i] /= centerSum[i].group;<br>                <span class="hljs-keyword">if</span> (bo &gt; dis[i]) &#123;<br>                    bo = dis[i];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> (bo - ao) / (Math.max(ao, bo));<br>    &#125;<br><br>    <span class="hljs-comment">//计算平均轮廓系数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">computeAverageSilhouetteCoefficient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; width; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; height; j++) &#123;<br>                sum += computeSilhouetteCoefficient(source[i][j], i, j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum /= (width * height);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>Main.java</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bigData;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">inPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;images\\in.jpg&quot;</span>;<br>        <span class="hljs-type">ImageCluster</span> <span class="hljs-variable">ic</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageCluster</span>();<br>        ic.kmeans(inPath, <span class="hljs-number">16</span>,<span class="hljs-number">200</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>参考链接：</p><ol><li><a href="https://blog.csdn.net/zhuzhuzhu22/article/details/53079114">【Java】K-means算法Java实现以及图像分割（续）</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像分割</tag>
      
      <tag>数据挖掘</tag>
      
      <tag>k-means</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Problem#6 题解</title>
    <link href="/2020/11/29/LeetCode-Problem-6-%E9%A2%98%E8%A7%A3/"/>
    <url>/2020/11/29/LeetCode-Problem-6-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><p><a href="https://leetcode.com/problems/zigzag-conversion/">题目传送</a></p><p>题意：给出一个字符串 <code>s</code> 和数字 <code>numRows</code> ，当字符串 s 按照锯齿形状排列时，从左到右，从上到下将字符连接起来，然后返回这个新的字符串。<code>numRows</code> 为字符的行数。</p><p>样例：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Input</span><span class="hljs-operator">:</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;PAYPALISHIRING&quot;</span><span class="hljs-operator">,</span> <span class="hljs-variable">numRows</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br><span class="hljs-variable">Output</span><span class="hljs-operator">:</span> <span class="hljs-string">&quot;PAHNAPLSIIGYIR&quot;</span><br><br><span class="hljs-variable">P</span>   <span class="hljs-variable">A</span>   <span class="hljs-variable">H</span>   <span class="hljs-built_in">N</span><br><span class="hljs-variable">A</span> <span class="hljs-variable">P</span> <span class="hljs-variable">L</span> <span class="hljs-variable">S</span> <span class="hljs-built_in">I</span> <span class="hljs-built_in">I</span> <span class="hljs-variable">G</span><br><span class="hljs-variable">Y</span>   <span class="hljs-built_in">I</span>   <span class="hljs-variable">R</span><br></code></pre></td></tr></table></figure><p>思路一（WA）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convert</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> numRows)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(numRows == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> slen = s.<span class="hljs-built_in">length</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i * (numRows - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> &lt; slen; i++) &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(i * (numRows - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd = vec.<span class="hljs-built_in">end</span>();<br>        <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>(); it != itEnd; ++it) &#123;<br>            res += s[*it];<br>        &#125;<br><br>        <span class="hljs-type">int</span> lenVec = vec.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; numRows - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; lenVec; j++) &#123;<br>                <span class="hljs-keyword">if</span>(vec[j] - i &gt;= <span class="hljs-number">0</span>) &#123;<br>                    res += s[vec[j] - i];<br>                &#125;<br>                <span class="hljs-keyword">if</span>(vec[j] + i &lt; slen) &#123;<br>                    res += s[vec[j] + i];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>(); it != itEnd; ++it) &#123;<br>            <span class="hljs-keyword">if</span>((*it) + numRows - <span class="hljs-number">1</span> &lt; slen)res += s[(*it) + numRows - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我的思路是将锯齿状的字符划分为：第一行、最后一行和其他行这三个部分。第一行字符的下标的规律是 <code>i*(numRows-1)*2 (i &gt;= 0)</code> ，而其他行字符的下标可以通过第一行字符下标加一个整数或减一个整数得到，最后一行的下标可以通过第一行字符的下标加 <code>numRows - 1</code>​ 得到。但是这样会有特例过不了， 没过的样例是：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-string">&quot;ABCD&quot;</span><br><span class="hljs-number">3</span><br><br><span class="hljs-variable">A</span><br><span class="hljs-variable">B</span> <span class="hljs-built_in">D</span><br><span class="hljs-built_in">C</span><br></code></pre></td></tr></table></figure><p>由于 <code>vec</code> 里面只有下标 0，所以没办法通过减一或加一访问到字符 D，所以就得到 <code>&quot;ABC&quot;</code> 的错误输出。我改进的想法有两个，一个是原有代码的基础上，在 <code>vec</code> 里面多加一个超过字符串长度的下标。然后在给 <code>res</code> 添加字符的时候判断下标是否在 <code>s.length()</code> 的范围内，二是只通过第一行下标加某两个特定数得到两个同一行的字符的下标，而不是原来的一加一减。然后我选择了第二个，因为需要改的地方较少。</p><p>思路二（AC）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convert</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> numRows)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(numRows == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> slen = s.<span class="hljs-built_in">length</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i * (numRows - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> &lt; slen; i++) &#123;<br>            vec.<span class="hljs-built_in">push_back</span>(i * (numRows - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd = vec.<span class="hljs-built_in">end</span>();<br>        <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>(); it != itEnd; ++it) &#123;<br>            res += s[*it];<br>        &#125;<br><br>        <span class="hljs-type">int</span> lenVec = vec.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; numRows - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; lenVec; j++) &#123;<br>               <span class="hljs-comment">// 改动的只有下面6行代码</span><br>                <span class="hljs-keyword">if</span>(vec[j] + i &lt; slen) &#123;<br>                    res += s[vec[j] + i];<br>                &#125;<br>                <span class="hljs-keyword">if</span>(vec[j] + ((numRows - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> - i) &lt; slen) &#123;<br>                    res += s[vec[j] + ((numRows - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> - i)];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>(); it != itEnd; ++it) &#123;<br>            <span class="hljs-keyword">if</span>((*it) + numRows - <span class="hljs-number">1</span> &lt; slen)res += s[(*it) + numRows - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Problem#5 题解</title>
    <link href="/2020/11/28/LeetCode-Problem-5-%E9%A2%98%E8%A7%A3/"/>
    <url>/2020/11/28/LeetCode-Problem-5-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><p><a href="https://leetcode.com/problems/longest-palindromic-substring">题目传送</a></p><p>题意：给出字符串 s ，返回最长回文子串。1 &lt;&#x3D; s.length &lt;&#x3D; 1000</p><p>思路一（TLE）：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; i + j &lt;= len; j++) &#123;<br>                string str = s.<span class="hljs-built_in">substr</span>(i, j);<br>                string pstr = str;<br>                <span class="hljs-built_in">reverse</span>(pstr.<span class="hljs-built_in">begin</span>(), pstr.<span class="hljs-built_in">end</span>());<br>                <span class="hljs-keyword">if</span>(pstr.<span class="hljs-built_in">compare</span>(str) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span>(j &gt; maxLen) &#123;<br>                        res = str;<br>                        maxLen = j;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>两层循环，遍历所有子串，然后判断该字串是否是回文字符串。不出意外地 TLE 了。然后想半天想不到思路，看了 Solution （<a href="https://leetcode.com/problems/longest-palindromic-substring/solution/">链接</a>），然后我选择的是第4个方法。从第一个遍历到最后一个字符，让每个字符当作回文的中心字符，然后得到最长的回文字串。</p><p>思路二（AC 代码）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> lenS = s.<span class="hljs-built_in">length</span>();<span class="hljs-comment">// 记录字符串的长度，便于直接使用，而不是用一次调用一次length方法</span><br>        <span class="hljs-type">int</span> start = <span class="hljs-number">-1</span>, length = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lenS; i++) &#123;<br>            <span class="hljs-type">int</span> oddLen = <span class="hljs-built_in">lenOfPalindrome</span>(s, i, i);<span class="hljs-comment">// 假设回文子串为奇数长度</span><br>            <span class="hljs-type">int</span> evenLen = <span class="hljs-built_in">lenOfPalindrome</span>(s, i, i + <span class="hljs-number">1</span>);<span class="hljs-comment">// 假设回文子串为偶数长度</span><br>            <span class="hljs-keyword">if</span>(length &lt; oddLen) &#123;<span class="hljs-comment">// 记录最长长度时的开始字符和长度</span><br>                start = i - oddLen / <span class="hljs-number">2</span>;<br>                length = oddLen;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(length &lt; evenLen) &#123;<span class="hljs-comment">// 同上</span><br>                start = i - evenLen / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                length = evenLen;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(start, length);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lenOfPalindrome</span><span class="hljs-params">(string str, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span><span class="hljs-comment">// 对str字符串从left向左遍历，从right向右遍历</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> lenStr = str.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; lenStr &amp;&amp; str[left] == str[right]) &#123;<br>            left--;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right - left - <span class="hljs-number">1</span>;<span class="hljs-comment">// 返回长度</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode Problem#3 解题思路</title>
    <link href="/2020/11/27/LeetCode-Problem-3-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
    <url>/2020/11/27/LeetCode-Problem-3-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">题目传送</a></p><p>题目概述：给出字符串 s ，找出它的没有重复字符的最长子串</p><p>思路1（错误思路）:</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(s[i]) != mp.<span class="hljs-built_in">end</span>()) &#123;<br>                tmp = i - mp[s[i]];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tmp += <span class="hljs-number">1</span>;<br>            &#125;<br>            mp[s[i]] = i;<br>            result = result &lt; tmp ? tmp : result;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码在测试用例为<code>&quot;abba&quot;</code>的时候出现问题。因为上面第11行的代码，我的想法是如果当前遍历到的字符是重复字符，那就从已经遍历过的字符的下一个字符开始计数，当遍历到<code>&quot;abba&quot;</code>的第二个<code>a</code>的时候，由于<code>mp</code>中已经有了<code>a</code>字符，它会将<code>tmp</code>设置为<code>3</code>，实际上这个子串有重复字符，所以错了。</p><p>后来我想到，既然已经遍历到了重复的字符，那么<code>mp</code>里面<code>value值</code>小于第一个重复字符的下标的字符都可以当作删掉了。</p><p>思路2（思路1的进化版，然而还是没AC。。。）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> del = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(s[i]) != mp.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">if</span>(del &lt; mp[s[i]]) &#123;<br>                    del = mp[s[i]];<br>                    tmp = i - mp[s[i]];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    tmp += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tmp += <span class="hljs-number">1</span>;<br>            &#125;<br>            mp[s[i]] = i;<br>            result = result &lt; tmp ? tmp : result;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>没有通过的测试样例是<code>&quot;abcabcbb&quot;</code>，同时我自己测的<code>&quot;abab&quot;</code>也过不了。原因在于<code>del</code>的初始化。。。我把它初始化为<code>0</code>了。。。然后遍历到第二个<code>a</code>的时候，12行<code>条件语句</code>判断之后就会进入<code>else语句</code>，<code>tmp+1</code>。这是明显错误的。将<code>del</code>初始化为<code>-1</code>就可以AC了。</p><p>思路3（最终AC代码）:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> del = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(s[i]) != mp.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">if</span>(del &lt; mp[s[i]]) &#123;<br>                    del = mp[s[i]];<br>                    tmp = i - mp[s[i]];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    tmp += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tmp += <span class="hljs-number">1</span>;<br>            &#125;<br>            mp[s[i]] = i;<br>            result = result &lt; tmp ? tmp : result;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心-区间调度问题</title>
    <link href="/2020/08/18/%E8%B4%AA%E5%BF%83-%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/18/%E8%B4%AA%E5%BF%83-%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><p>题意：有<code>n</code>项工作，每项工作在<code>s[i]</code>时间开始，<code>t[i]</code>时间结束。对于每项工作，你可以选择是否参与。一旦参与就不能中途退出。参与的工作时间段不能重叠（开始的瞬间和结束的瞬间也不能重叠）。</p><p>数据范围：$1\leq n\leq 100000$  $1\leq s[i] \leq t[i]\leq 10^9$ </p><p>思路：优先选择结束时间最早的工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span><span class="hljs-comment">//sort的头文件 </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">//pair的头文件 </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">100000</span>;<br><span class="hljs-type">int</span> n;<br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p[MAX_N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;<span class="hljs-comment">//a、b均为临时存储数据的变量</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);<br>        p[i].first = b;<span class="hljs-comment">//这里将结束时间设置为first，可以便捷地使用sort从小到大排序</span><br>        p[i].second = a;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(p, p + n);<span class="hljs-comment">//sort对pair排序是对first进行排序，而不是second</span><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, x = <span class="hljs-number">0</span>;<span class="hljs-comment">//cnt为选择的工作数量，x记录目前选择的工作中最晚结束时间</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(x &lt; p[i].second) &#123;<br>            cnt++;<br>            x = p[i].first;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 2020/1/18</title>
    <link href="/2020/01/18/%E9%A2%98%E8%A7%A3-2020-1-18/"/>
    <url>/2020/01/18/%E9%A2%98%E8%A7%A3-2020-1-18/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><h5 id="1039-Course-List-for-Student-25point-s"><a href="#1039-Course-List-for-Student-25point-s" class="headerlink" title="1039 Course List for Student (25point(s))"></a>1039 Course List for Student (25point(s))</h5><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805447855292416">传送门</a></p><p>题意：输入报名某门课程（以数字为编号）的学生的名字（以三个字母加一个数字为编号），按名字字母序输出每个人名以及对应的报的课程数目及课程。</p><p>思路：用<code>unordered_map&lt;string, vector&lt;int&gt; &gt;</code>来存储每个人名对应的课程（<code>unordered_map</code>的<code>key</code>不会进行排序，是通过<code>hash</code>来直接查找元素的，时间复杂度为O(1)，所以节省了时间，<code>map</code>用了红黑树，查找元素时的时间复杂度为O( log(n)））这题我用<code>map</code>时TLE了，而用<code>unordered_map</code>就过了。还有就是，这题如果用<code>scanf</code>和<code>printf</code>来代替<code>cin</code>和<code>cout</code>也可以节省时间，或者用<code>char*</code>代替<code>string</code>。有兴趣的可以把时间改的更少。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>unordered_map&lt;string, vector&lt;<span class="hljs-type">int</span>&gt; &gt; student;<span class="hljs-comment">//记录学生姓名对应所选的课程</span><br>vector&lt;string&gt; name;<span class="hljs-comment">//记录学生姓名</span><br><span class="hljs-type">int</span> n, k;<span class="hljs-comment">//n为学生个数，k为课程总数</span><br>vector&lt;<span class="hljs-type">int</span>&gt; vt;<span class="hljs-comment">//用于临时存放某个学生所选的课程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    name.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">40001</span>);<span class="hljs-comment">//这个函数的用法可以去搜一下，有的地方这个函数不可或缺</span><br>    vt.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">2501</span>);<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        string str;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= b; j++) &#123;<br>            cin &gt;&gt; str;<br>            student[str].<span class="hljs-built_in">push_back</span>(a);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        string na;<br>        cin &gt;&gt; na;<br>        name.<span class="hljs-built_in">push_back</span>(na);<br>    &#125;<br>    vector&lt;string&gt;::iterator it;<br>    <span class="hljs-keyword">for</span>(it = name.<span class="hljs-built_in">begin</span>(); it != name.<span class="hljs-built_in">end</span>(); it++) &#123;<br>        <span class="hljs-keyword">if</span>(student.<span class="hljs-built_in">find</span>(*it) == student.<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-comment">//当没有找到对应的key时，返回unordered_map::end()，这和map是一样的</span><br>            cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; 0&quot;</span> &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            vt = student[*it];<br>            <span class="hljs-built_in">sort</span>(vt.<span class="hljs-built_in">begin</span>(), vt.<span class="hljs-built_in">end</span>());<br>            cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; vt.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt;::iterator itt;<br>            <span class="hljs-keyword">for</span>(itt = vt.<span class="hljs-built_in">begin</span>(); itt != vt.<span class="hljs-built_in">end</span>(); itt++) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *itt;<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1047-Student-List-for-Course"><a href="#1047-Student-List-for-Course" class="headerlink" title="1047 Student List for Course"></a><strong>1047</strong> <strong>Student List for Course</strong></h5><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805433955368960">传送门</a></p><p>题意：这题的输入输出和上面那题的输入输出正好相反，输入学生所选的课程，输出选择课程的人名。</p><p>思路：正常地使用<code>vector</code>构建二维数组就可以了，这题一开始我用<code>cin</code>和<code>cout</code>还有<code>string</code>超时了，然后我改成<code>scanf</code>和<code>printf</code>还有<code>char*</code>之后就ac了。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;vector&lt;<span class="hljs-type">char</span>*&gt; &gt; name;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">char</span>* a,<span class="hljs-type">char</span> *b)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(a,b)&lt;<span class="hljs-number">0</span>;<span class="hljs-comment">//按照姓名的字母序排序，不能直接比较</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    <span class="hljs-comment">//cin &gt;&gt; n &gt;&gt; k;</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);<br>    name.<span class="hljs-built_in">resize</span>(k + <span class="hljs-number">1</span>);<span class="hljs-comment">//这个是构建二维数组时必须的东西，不然报错</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>        name[i].<span class="hljs-built_in">reserve</span>(n);<br>    &#125;<br><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-comment">//cin &gt;&gt; str &gt;&gt; x;</span><br>        <span class="hljs-type">char</span>* str=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">5</span>];<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s %d&quot;</span>,str,&amp;x);<br>        <span class="hljs-type">int</span> y;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= x; j++) &#123;<br>            <span class="hljs-comment">//cin &gt;&gt; y;</span><br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;y);<br>            name[y].<span class="hljs-built_in">push_back</span>(str);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>        <span class="hljs-built_in">sort</span>(name[i].<span class="hljs-built_in">begin</span>(), name[i].<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-comment">//cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; name[i].size() &lt;&lt; endl;</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,i,name[i].<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">char</span>*&gt;::iterator it = name[i].<span class="hljs-built_in">begin</span>(); it != name[i].<span class="hljs-built_in">end</span>(); it++) &#123;<br>            <span class="hljs-comment">//cout &lt;&lt; *it &lt;&lt; endl;</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,*it);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1100-Mars-Numbers"><a href="#1100-Mars-Numbers" class="headerlink" title="1100 Mars Numbers"></a><strong>1100</strong> <strong>Mars Numbers</strong></h5><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805367156883456">传送门</a></p><p>题意：将10进制的数字转换为13进制，然后转换为“火星语”输出，或者输入“火星语”，转换为10进制的数字。</p><p>思路：构建<code>map</code>时我没有用<code>string</code>，而是用<code>const char*</code>，所以比较麻烦。当<code>const char*</code>作为<code>key</code>时，<code>map</code>模板第三个参数必须要有，用来排序时的比较。否则会用地址来比较，然后不知道为什么无法使用<code>const char*</code>类型的变量（例如<code>const char* s;</code>）来进行访问，只能使用常量（例如<code>&quot;tret&quot;</code>），这个有兴趣的可以自己搜一下。还有就是13的结果不是<code>tam tret</code> 而是<code>tam</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<span class="hljs-comment">//这是必须要有的，不然无法正常使用map</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(a, b) &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br>map&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">int</span>, cmp&gt; low;<span class="hljs-comment">//注意第三个参数</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; hlow, hhigh;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">charToInt</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span><span class="hljs-comment">//将字符串转换为数字</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(s), ans = <span class="hljs-number">0</span>, ii = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        ans += (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * ii;<br>        ii *= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    low[<span class="hljs-string">&quot;tret&quot;</span>] = <span class="hljs-number">0</span>;<br>    low[<span class="hljs-string">&quot;jan&quot;</span>] = <span class="hljs-number">1</span>;<br>    low[<span class="hljs-string">&quot;tam&quot;</span>] = <span class="hljs-number">13</span>;<br>    low[<span class="hljs-string">&quot;feb&quot;</span>] = <span class="hljs-number">2</span>;<br>    low[<span class="hljs-string">&quot;hel&quot;</span>] = <span class="hljs-number">26</span>;<br>    low[<span class="hljs-string">&quot;mar&quot;</span>] = <span class="hljs-number">3</span>;<br>    low[<span class="hljs-string">&quot;maa&quot;</span>] = <span class="hljs-number">39</span>;<br>    low[<span class="hljs-string">&quot;apr&quot;</span>] = <span class="hljs-number">4</span>;<br>    low[<span class="hljs-string">&quot;huh&quot;</span>] = <span class="hljs-number">52</span>;<br>    low[<span class="hljs-string">&quot;may&quot;</span>] = <span class="hljs-number">5</span>;<br>    low[<span class="hljs-string">&quot;tou&quot;</span>] = <span class="hljs-number">65</span>;<br>    low[<span class="hljs-string">&quot;jun&quot;</span>] = <span class="hljs-number">6</span>;<br>    low[<span class="hljs-string">&quot;kes&quot;</span>] = <span class="hljs-number">78</span>;<br>    low[<span class="hljs-string">&quot;jly&quot;</span>] = <span class="hljs-number">7</span>;<br>    low[<span class="hljs-string">&quot;hei&quot;</span>] = <span class="hljs-number">91</span>;<br>    low[<span class="hljs-string">&quot;aug&quot;</span>] = <span class="hljs-number">8</span>;<br>    low[<span class="hljs-string">&quot;elo&quot;</span>] = <span class="hljs-number">104</span>;<br>    low[<span class="hljs-string">&quot;sep&quot;</span>] = <span class="hljs-number">9</span>;<br>    low[<span class="hljs-string">&quot;syy&quot;</span>] = <span class="hljs-number">117</span>;<br>    low[<span class="hljs-string">&quot;oct&quot;</span>] = <span class="hljs-number">10</span>;<br>    low[<span class="hljs-string">&quot;lok&quot;</span>] = <span class="hljs-number">130</span>;<br>    low[<span class="hljs-string">&quot;nov&quot;</span>] = <span class="hljs-number">11</span>;<br>    low[<span class="hljs-string">&quot;mer&quot;</span>] = <span class="hljs-number">143</span>;<br>    low[<span class="hljs-string">&quot;dec&quot;</span>] = <span class="hljs-number">12</span>;<br>    low[<span class="hljs-string">&quot;jou&quot;</span>] = <span class="hljs-number">156</span>;<br>    hlow[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;tret&quot;</span>;<br>    hlow[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;jan&quot;</span>;<br>    hhigh[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;tam&quot;</span>;<br>    hlow[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;feb&quot;</span>;<br>    hhigh[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;hel&quot;</span>;<br>    hlow[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;mar&quot;</span>;<br>    hhigh[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;maa&quot;</span>;<br>    hlow[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;apr&quot;</span>;<br>    hhigh[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;huh&quot;</span>;<br>    hlow[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;may&quot;</span>;<br>    hhigh[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;tou&quot;</span>;<br>    hlow[<span class="hljs-number">6</span>] = <span class="hljs-string">&quot;jun&quot;</span>;<br>    hhigh[<span class="hljs-number">6</span>] = <span class="hljs-string">&quot;kes&quot;</span>;<br>    hlow[<span class="hljs-number">7</span>] = <span class="hljs-string">&quot;jly&quot;</span>;<br>    hhigh[<span class="hljs-number">7</span>] = <span class="hljs-string">&quot;hei&quot;</span>;<br>    hlow[<span class="hljs-number">8</span>] = <span class="hljs-string">&quot;aug&quot;</span>;<br>    hhigh[<span class="hljs-number">8</span>] = <span class="hljs-string">&quot;elo&quot;</span>;<br>    hlow[<span class="hljs-number">9</span>] = <span class="hljs-string">&quot;sep&quot;</span>;<br>    hhigh[<span class="hljs-number">9</span>] = <span class="hljs-string">&quot;syy&quot;</span>;<br>    hlow[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;oct&quot;</span>;<br>    hhigh[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;lok&quot;</span>;<br>    hlow[<span class="hljs-number">11</span>] = <span class="hljs-string">&quot;nov&quot;</span>;<br>    hhigh[<span class="hljs-number">11</span>] = <span class="hljs-string">&quot;mer&quot;</span>;<br>    hlow[<span class="hljs-number">12</span>] = <span class="hljs-string">&quot;dec&quot;</span>;<br>    hhigh[<span class="hljs-number">12</span>] = <span class="hljs-string">&quot;jou&quot;</span>;<br><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">char</span> ch;<br>        <span class="hljs-type">char</span> s1[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;, s2[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> ii = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> *s = s1;<br>        <span class="hljs-keyword">while</span>((ch = <span class="hljs-built_in">getchar</span>()) != <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span>(ch != <span class="hljs-string">&#x27; &#x27;</span>) s[ii++] = ch;<br>            <span class="hljs-keyword">else</span> &#123;<br>                s = s2;<br>                ii = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(s1[<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s1[<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br><br>            <span class="hljs-type">int</span> ans = <span class="hljs-built_in">charToInt</span>(s1);<br>            <span class="hljs-type">int</span> t1 = ans % <span class="hljs-number">13</span>;<br>            ans -= t1;<br>            <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, hlow[t1]);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t1 == <span class="hljs-number">0</span>) &#123;<br>                ans /= <span class="hljs-number">13</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, hhigh[ans]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans /= <span class="hljs-number">13</span>;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %s\n&quot;</span>, hhigh[ans], hlow[t1]);<br><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(s2) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ss1 = s1;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, low[ss1]);<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ss1 = s1;<br>                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ss2 = s2;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, low[ss2] + low[ss1]);<br><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2019/12/21 题解</title>
    <link href="/2019/12/21/2019-12-21-%E9%A2%98%E8%A7%A3/"/>
    <url>/2019/12/21/2019-12-21-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><em>注：本题解的题目缺失</em></p><p><strong><span id="more"></span></strong></p><h4 id="火星上的生命"><a href="#火星上的生命" class="headerlink" title="火星上的生命"></a>火星上的生命</h4><p><a href="https://oj.ncutea.com/problem/10043">传送门</a></p><p>思路：这题我是用模拟，将A T U变为0 1 2，然后弄个3*3的二维数组，正好对应九个字符串，然后就是将输入的字符串转换为int数组，遍历得到结果。理解上的难点：如果没有遇到end就算None。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* pl[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&quot;Glycine&quot;</span>, <span class="hljs-string">&quot;Cysteine&quot;</span>, <span class="hljs-string">&quot;START&quot;</span>, <span class="hljs-string">&quot;END&quot;</span>, <span class="hljs-string">&quot;END&quot;</span>, <span class="hljs-string">&quot;Arginine&quot;</span>, <span class="hljs-string">&quot;Serine&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>, <span class="hljs-string">&quot;Lysine&quot;</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    string getstr, putstr[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, f[<span class="hljs-number">35</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    cin &gt;&gt; getstr;<br>    <span class="hljs-type">int</span> lg = getstr.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lg; i++) &#123; <span class="hljs-comment">//将字符转换为数字</span><br>        <span class="hljs-keyword">if</span>(getstr[i] == <span class="hljs-string">&#x27;A&#x27;</span>) f[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(getstr[i] == <span class="hljs-string">&#x27;T&#x27;</span>) f[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(getstr[i] == <span class="hljs-string">&#x27;U&#x27;</span>) f[i] = <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lg - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(pl[f[i]][f[i + <span class="hljs-number">1</span>]], <span class="hljs-string">&quot;START&quot;</span>)) &#123; <span class="hljs-comment">//c语言字符串不能直接比较是否相等，所以用strcmp比较</span><br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">strcmp</span>(pl[f[j]][f[j + <span class="hljs-number">1</span>]], <span class="hljs-string">&quot;END&quot;</span>)) &#123;<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(pl[f[j]][f[j + <span class="hljs-number">1</span>]], <span class="hljs-string">&quot;DELETE&quot;</span>)) cnt--;<br>                <span class="hljs-keyword">else</span> putstr[cnt++] = pl[f[j]][f[j + <span class="hljs-number">1</span>]];<br>                j += <span class="hljs-number">2</span>; <span class="hljs-comment">//判断完了就判断下一个序列</span><br>                <span class="hljs-keyword">if</span>(j &gt;= lg - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//判断是否有end结尾，如果没有就说明是无效序列</span><br>                    cnt = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt &lt;= <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;None&quot;</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++) &#123;<br>            cout &lt;&lt; putstr[i];<br>            <span class="hljs-keyword">if</span>(i != cnt - <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="僵尸危机"><a href="#僵尸危机" class="headerlink" title="僵尸危机"></a>僵尸危机</h4><p><a href="https://oj.ncutea.com/problem/10044">传送门</a></p><p>思路：这题难点在于理解题意，理解了题意就很简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-type">int</span> f[<span class="hljs-number">1000</span>], a[<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    a[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> day = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(a[day] &lt; n) &#123;<br>        f[day + <span class="hljs-number">1</span>] = a[day] - (f[day] % <span class="hljs-number">4</span> ? f[day] / <span class="hljs-number">4</span> + <span class="hljs-number">1</span> : f[day] / <span class="hljs-number">4</span>);<br>        a[day + <span class="hljs-number">1</span>] = f[day + <span class="hljs-number">1</span>] * <span class="hljs-number">3</span>;<br>        day++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(day &lt;= <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d day&quot;</span>, day + <span class="hljs-number">1</span>); <span class="hljs-comment">//注意是day+1</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d days&quot;</span>, day + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="再去明星演唱会"><a href="#再去明星演唱会" class="headerlink" title="再去明星演唱会"></a>再去明星演唱会</h4><p><a href="https://oj.ncutea.com/problem/10045">传送门</a></p><p>思路：简单的dfs，然后用栈（我用的是vector来模拟栈）存储记录点座标的结构体，当到达目标座标的时候，按格式输出栈里面的所有座标，而且要分四次在四个角上使用dfs，如果角上坐了人，就输出-1，或者无法到达目标座标也输出-1，这里用flag来标志是否能到达目标座标。（由于之前刷题时，题目测试数据里面有目标座标可能也坐了人，所以要特判，此时算是到达了目标座标，不过比赛的数据我不知道有没有这种测试数据）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>], nex[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, n, m, ex, ey, flag = <span class="hljs-number">0</span>, book[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>]; <span class="hljs-comment">//a数组存储某点是否有人，next用于按照左下右上的顺序遍历，book数组用来判断是否已经走过这个点。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br>&#125;;<br>vector&lt;node&gt; ss;<span class="hljs-comment">//记录已经走过的路径</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> <span class="hljs-comment">//完全是dfs模板，</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x == ex &amp;&amp; y == ey) &#123;<br>        flag = <span class="hljs-number">1</span>; <span class="hljs-comment">//说明从这个点可以到达目标座标</span><br>        <span class="hljs-type">int</span> len = ss.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d,%d)&quot;</span>, ss[i].x, ss[i].y);<br>            <span class="hljs-keyword">if</span>(i != len - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&gt;&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-type">int</span> tx = x + nex[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ty = y + nex[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(tx &lt; <span class="hljs-number">1</span> || ty &lt; <span class="hljs-number">1</span> || tx &gt; n || ty &gt; m || book[tx][ty] || (a[tx][ty] == <span class="hljs-number">1</span> &amp;&amp; !(tx == ex &amp;&amp; ty == ey))) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//这里的最后括号里面的特判是因为目标座标可能有人，也算可以到达，这是因为之前有个数据卡了我很多次。。。这个比赛的数据我不知道有没有卡。。。</span><br>        book[tx][ty] = <span class="hljs-number">1</span>;<br>        node tn;<br>        tn.x = tx;<br>        tn.y = ty;<br>        ss.<span class="hljs-built_in">push_back</span>(tn);<br>        <span class="hljs-built_in">dfs</span>(tx, ty);<br>        ss.<span class="hljs-built_in">pop_back</span>();<br>        book[tx][ty] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;ex, &amp;ey);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> beg[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, n, <span class="hljs-number">1</span>, n, m&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(a[beg[i][<span class="hljs-number">0</span>]][beg[i][<span class="hljs-number">1</span>]] == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//判断角上是否有人，有人就不能走</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ii = <span class="hljs-number">1</span>; ii &lt;= n; ii++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>                book[ii][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br><br>        book[beg[i][<span class="hljs-number">0</span>]][beg[i][<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>        node tn;<br>        tn.x = beg[i][<span class="hljs-number">0</span>];<br>        tn.y = beg[i][<span class="hljs-number">1</span>];<br>        ss.<span class="hljs-built_in">push_back</span>(tn);<br>        <span class="hljs-built_in">dfs</span>(beg[i][<span class="hljs-number">0</span>], beg[i][<span class="hljs-number">1</span>]);<br>        ss.<span class="hljs-built_in">pop_back</span>();<br>        book[beg[i][<span class="hljs-number">0</span>]][beg[i][<span class="hljs-number">1</span>]] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//这个角无法到达目标座标</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="摸鱼"><a href="#摸鱼" class="headerlink" title="摸鱼"></a>摸鱼</h4><p><a href="https://oj.ncutea.com/problem/10046">传送门</a></p><p>思路：这题我是用一个结构体存储每个人的<strong>编号</strong>、<strong>随机数</strong>、<strong>对他%的人数</strong>。每当输入一个朋友关系的时候，判断谁的<strong>随机数</strong>大，然后大的那个人的 <strong>对他%的人数</strong> 减一（就是减掉他的朋友），然后把这个结构体数组按照<strong>随机数</strong>大小从小到大排序，然后根据下标计算每个人的<strong>对他%的人数</strong>，再按照编号排序，输出%他的人数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> f[<span class="hljs-number">200100</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> num, random;<br>    <span class="hljs-type">int</span> bai;<br>&#125; ss[<span class="hljs-number">200100</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.random != b.random) <span class="hljs-keyword">return</span> a.random &lt; b.random;<br>    <span class="hljs-keyword">return</span> a.num &lt; b.num;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(node a, node b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.num &lt; b.num;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;ss[i].random);<br>        ss[i].num = i;<br>        ss[i].bai = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);<br>        <span class="hljs-keyword">if</span>(ss[a].random &lt; ss[b].random) ss[b].bai--;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ss[a].random &gt; ss[b].random) ss[a].bai--;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(ss + <span class="hljs-number">1</span>, ss + n + <span class="hljs-number">1</span>, cmp);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">//这是重点代码，判断有几个人的随机数小于现在这个人</span><br>        <span class="hljs-keyword">if</span>(ss[i - <span class="hljs-number">1</span>].random == ss[i].random) ss[i].bai += cnt;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cnt = i - <span class="hljs-number">1</span>;<br>            ss[i].bai += cnt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    printf(&quot;\n&quot;);</span><br><span class="hljs-comment">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="hljs-comment">    printf(&quot;%d&quot;,ss[i].random);</span><br><span class="hljs-comment">    if(i!=n) printf(&quot; &quot;);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">sort</span>(ss + <span class="hljs-number">1</span>, ss + n + <span class="hljs-number">1</span>, cmp1);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ss[i].bai &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : ss[i].bai);<br>        <span class="hljs-keyword">if</span>(i != n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>题解</title>
    <link href="/2019/09/30/%E9%A2%98%E8%A7%A3%EF%BC%88%E8%A1%A5%EF%BC%89/"/>
    <url>/2019/09/30/%E9%A2%98%E8%A7%A3%EF%BC%88%E8%A1%A5%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><h6 id="洛谷-p2812-回家"><a href="#洛谷-p2812-回家" class="headerlink" title="洛谷 p2812 回家"></a>洛谷 p2812 回家</h6><p><a href="https://www.luogu.org/problem/P2802">链接</a></p><p>思路：直接用dfs搜索，需要注意的是当移动时，有的点只可以经过一次（起点和鼠标所在的点，防止走回头路），有的点则可以经过两次（一次是残血，一次是走到附近加了血之后）。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>, n, m, a[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>], hp = <span class="hljs-number">6</span>, min = <span class="hljs-number">0x3f3f3f3f</span>, sum = <span class="hljs-number">0</span>, book[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> next[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(hp == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//此时没血了,不能走了</span><br>    <span class="hljs-keyword">if</span>(a[x][y] == <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">//到达鼠标所在的点</span><br>        hp = <span class="hljs-number">6</span>;<br>        book[x][y] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(a[x][y] == <span class="hljs-number">3</span>) &#123; <span class="hljs-comment">//到达终点</span><br>        flag = <span class="hljs-number">1</span>;<br>        min = sum &lt; min ? sum : min;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> tx, ty;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        tx = x + next[i][<span class="hljs-number">0</span>];<br>        ty = y + next[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(a[tx][ty] == <span class="hljs-number">2</span> || tx &lt; <span class="hljs-number">1</span> || tx &gt; n || ty &lt; <span class="hljs-number">1</span> || ty &gt; m || a[tx][ty] == <span class="hljs-number">0</span> || (a[tx][ty] == <span class="hljs-number">4</span> &amp;&amp; book[tx][ty] == <span class="hljs-number">1</span>) || book[tx][ty] == <span class="hljs-number">2</span> ) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> t = hp;<br>        hp--;<br>        sum++;<br>        book[tx][ty]++;<br>        <span class="hljs-built_in">dfs</span>(tx, ty);<br>        book[tx][ty]--;<br>        sum--;<br>        hp = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span> == a[i][j]) &#123;<br>                x = i;<br>                y = j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(x, y);<br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, min);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="洛谷-p1443-马的遍历"><a href="#洛谷-p1443-马的遍历" class="headerlink" title="洛谷 p1443 马的遍历"></a>洛谷 p1443 马的遍历</h6><p><a href="https://www.luogu.org/problem/P1443">链接</a></p><p>思路：直接套模板。。。bfs。。。（虽然很水，但可以复习bfs模板。。。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-type">int</span> n, m, startx, starty, a[<span class="hljs-number">401</span>][<span class="hljs-number">401</span>], book[<span class="hljs-number">401</span>][<span class="hljs-number">401</span>], next[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">1</span> || y &lt; <span class="hljs-number">1</span> || x &gt; n || y &gt; m) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> step;<br>&#125; que[<span class="hljs-number">160001</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;startx, &amp;starty);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            a[i][j] = <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    a[startx][starty] = <span class="hljs-number">0</span>;<br>    book[startx][starty] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> head = <span class="hljs-number">1</span>, tail = <span class="hljs-number">1</span>;<br>    que[tail].x = startx;<br>    que[tail].y = starty;<br>    que[tail].step = <span class="hljs-number">0</span>;<br>    tail++;<br>    <span class="hljs-keyword">while</span>(head &lt; tail) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>            <span class="hljs-type">int</span> tx = que[head].x + next[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> ty = que[head].y + next[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(book[tx][ty] == <span class="hljs-number">1</span> || !<span class="hljs-built_in">judge</span>(tx, ty) ) <span class="hljs-keyword">continue</span>;<br>            que[tail].x = tx;<br>            que[tail].y = ty;<br>            a[tx][ty] = que[tail].step = que[head].step + <span class="hljs-number">1</span>;<br>            tail++;<br>            book[tx][ty] = <span class="hljs-number">1</span>;<br>        &#125;<br>        head++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-5d&quot;</span>, a[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="洛谷-p1892-团伙"><a href="#洛谷-p1892-团伙" class="headerlink" title="洛谷 p1892 团伙"></a>洛谷 p1892 团伙</h6><p><a href="https://www.luogu.org/problem/P1892">链接</a></p><p>思路：这是一个并查集的题目，需要注意的就是，敌人的敌人是朋友，所以在判断敌人时，要多弄一个把敌人的敌人合并为朋友的语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m, f[<span class="hljs-number">1001</span>], e[<span class="hljs-number">1001</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getf</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[u] == u) <span class="hljs-keyword">return</span> u;<br>    f[u] = <span class="hljs-built_in">getf</span>(f[u]);<br>    <span class="hljs-keyword">return</span> f[u];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t1 = <span class="hljs-built_in">getf</span>(u);<br>    <span class="hljs-type">int</span> t2 = <span class="hljs-built_in">getf</span>(v);<br>    <span class="hljs-keyword">if</span>(t1 == t2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    f[v] = t1;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        f[i] = i;<br>        e[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-type">char</span> ch;<br>        <span class="hljs-type">int</span> p, q;<br>        <span class="hljs-comment">//scanf(&quot;%c %d %d&quot;,&amp;ch,&amp;p,&amp;q);</span><br>        cin &gt;&gt; ch &gt;&gt; p &gt;&gt; q;<br>        <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;F&#x27;</span>) &#123;<br>            <span class="hljs-built_in">merge</span>(p, q);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;E&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span>(e[p] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">merge</span>(e[p], q);<br>            &#125; <span class="hljs-keyword">else</span> e[p] = q;<br>            <span class="hljs-keyword">if</span>(e[q] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">merge</span>(e[q], p);<br>            &#125; <span class="hljs-keyword">else</span> e[q] = p;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(f[i] == i) sum++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="洛谷-p2024食物链"><a href="#洛谷-p2024食物链" class="headerlink" title="洛谷 p2024食物链"></a>洛谷 p2024食物链</h6><p><a href="https://www.luogu.org/problem/P2024">链接</a></p><p>思路：这题我没想到思路，通过看题解的思路来写代码。这题是种类并查集 的题目，通过将初始数组的大小置为n的倍数，然后将数组划分为若干个集合（1 ~ n , n+1 ~ 2n , …  每个集合里面有n个元素），第二个集合是第一个集合的天敌，第三个集合是第二个集合的天敌，第一个集合是第三个集合的天敌，然后通过将同类动物放在同一个集合里讨论，不同类动物（敌对）则在不同的集合里面讨论。当对动物进行合并时，要同时对不同的集合进行操作。当对输入的东西进行讨论是则只需要只需要对一组集合进行讨论就可以了。（种类并查集求的并非具体种类，而是关系！）<a href="https://www.luogu.org/blog/Sooke/solution-p2024">参考的题解链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-type">int</span> n, k, f[<span class="hljs-number">150001</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getf</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> <span class="hljs-comment">//找同类</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> f[u] == u ? u : f[u] = <span class="hljs-built_in">getf</span>(f[u]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n * <span class="hljs-number">3</span>; i++) f[i] = i;<br>    <span class="hljs-type">int</span> a, x, y, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(; k; k--) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;x, &amp;y);<br>        <span class="hljs-keyword">if</span>(x &gt; n || y &gt; n) &#123;<br>            sum++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">getf</span>(x) == <span class="hljs-built_in">getf</span>(y + n) || <span class="hljs-built_in">getf</span>(x + n) == <span class="hljs-built_in">getf</span>(y)) &#123; <span class="hljs-comment">//当x和y时互相为天敌时，这个输入的语句为假</span><br>                sum++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//将x和y设置为同类(三个集合都要设置)</span><br>                f[<span class="hljs-built_in">getf</span>(x)] = <span class="hljs-built_in">getf</span>(y);<br>                f[<span class="hljs-built_in">getf</span>(x + n)] = <span class="hljs-built_in">getf</span>(y + n);<br>                f[<span class="hljs-built_in">getf</span>(x + <span class="hljs-number">2</span> * n)] = <span class="hljs-built_in">getf</span>(y + <span class="hljs-number">2</span> * n);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">getf</span>(x) == <span class="hljs-built_in">getf</span>(y) || <span class="hljs-built_in">getf</span>(x + n) == <span class="hljs-built_in">getf</span>(y)) &#123; <span class="hljs-comment">//判断是否是同类</span><br>                sum++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//将x和y设置为天敌关系</span><br>                f[<span class="hljs-built_in">getf</span>(x)] = <span class="hljs-built_in">getf</span>(y + n);<br>                f[<span class="hljs-built_in">getf</span>(x + n)] = <span class="hljs-built_in">getf</span>(y + <span class="hljs-number">2</span> * n);<br>                f[<span class="hljs-built_in">getf</span>(x + <span class="hljs-number">2</span> * n)] = <span class="hljs-built_in">getf</span>(y);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="洛谷-p3371-【模板】单源最短路径（弱化版）"><a href="#洛谷-p3371-【模板】单源最短路径（弱化版）" class="headerlink" title="洛谷 p3371 【模板】单源最短路径（弱化版）"></a>洛谷 p3371 【模板】单源最短路径（弱化版）</h6><p><a href="https://www.luogu.org/problem/P3371">链接</a></p><p>思路：这题如果用邻接矩阵会有三个MLE，原因是邻接矩阵数组过大（10000 X 10000），然后用了一些时间学习链式前向星。所以我最后ac的解法是Dijkstra+链式前向星 。还有就是用快读的方式减少运行时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Maxn 10001</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n, m, s, dis[Maxn], book[Maxn];<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, head[Maxn] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//head用来记录以某个起点的第一条边，cnt用来记录edge的当前下标</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> next;<span class="hljs-comment">//（同一起点）下一条边的数组下标</span><br>    <span class="hljs-type">int</span> to;<span class="hljs-comment">//边的终点</span><br>    <span class="hljs-type">int</span> w;<span class="hljs-comment">//边的长度(权)</span><br>&#125; edge[<span class="hljs-number">500001</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span> <span class="hljs-comment">//将以u为起点v为终点的边存储到链式前向星里面</span></span><br><span class="hljs-function"></span>&#123;<br>    edge[cnt].to = v;<br>    edge[cnt].w = w;<br>    edge[cnt].next = head[u];<br>    head[u] = cnt++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-comment">//快读</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        n = (n &lt;&lt; <span class="hljs-number">1</span>) + (n &lt;&lt; <span class="hljs-number">3</span>) + ( ch &amp; <span class="hljs-number">15</span> );<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    m = <span class="hljs-built_in">read</span>();<br>    s = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) dis[i] = inf;<br>    dis[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(; m; m--) &#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        u = <span class="hljs-built_in">read</span>();<br>        v = <span class="hljs-built_in">read</span>();<br>        w = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-built_in">add</span>(u, v, w);<br>    &#125;<br>    <span class="hljs-type">int</span> t = s, min = inf;<br>    <span class="hljs-keyword">while</span>(!book[t]) &#123; <span class="hljs-comment">//条件为当dis存在未确定的边里面的最小边,至于原因可以看dijkstra算法</span><br>        book[t] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[t]; i; i = edge[i].next) &#123; <span class="hljs-comment">//从某一始点的第一条边开始遍历，松弛dis数组</span><br>            <span class="hljs-keyword">if</span>(!book[edge[i].to] &amp;&amp; dis[edge[i].to] &gt; dis[t] + edge[i].w) dis[edge[i].to] = dis[t] + edge[i].w;<br>        &#125;<br>        min = inf;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">//查看是否所有点已经松弛完成，即所有点都确定了</span><br>            <span class="hljs-keyword">if</span>(!book[i] &amp;&amp; dis[i] &lt; min) &#123;<br>                t = i;<br>                min = dis[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(dis[i] != inf)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, dis[i]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2147483647 &quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="洛谷-P1462-通往奥格瑞玛的道路"><a href="#洛谷-P1462-通往奥格瑞玛的道路" class="headerlink" title="洛谷 P1462 通往奥格瑞玛的道路"></a>洛谷 P1462 通往奥格瑞玛的道路</h6><p><a href="https://www.luogu.org/problem/P1462">链接</a></p><p>思路：这题我写了两天（改代码和学习，我太菜了）。。。题意的交费最多的最小值就是当他能到达终点时，肯定有个收费最多的点，在所有可能的路径中，收费最多的点的最小值。用dijkstra+二分来写（还要用堆优化，不然会tle。。。卡了将近一天），主要是将点权二分，然后找最短满足点权条件的最短路径，一直二分，最后找到满足条件的最小值。堆优化就是找出利用priority_queue（大佬也可以用手写最小堆）来记录dijkstra里面遍历到的点，其中要自定义一个struct cmp 来作为模板参数的第三个参数（以!cmp录入，和sort函数不同）。然后就是二分后的top（将大于top的点直接排除）要作为check函数里面部分条件的判断依据（如代码）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXn = <span class="hljs-number">10001</span>; <span class="hljs-comment">//最大的点的数目</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, dis[MAXn], book[MAXn] = &#123;<span class="hljs-number">0</span>&#125;, n, m, b, head[MAXn], f[MAXn];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123; <span class="hljs-comment">//我没试直接写个cmp函数可不可以。。。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//因为优先出列判定为!cmp，所以反向定义实现最小值优先</span><br>        <span class="hljs-keyword">return</span> dis[a] &gt; dis[b];<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span> *p, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> <span class="hljs-comment">//快排。。。（tle后各种优化，连sort都换了）</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> temp = p[left];<br>    <span class="hljs-type">int</span> l = left, r = right;<br>    <span class="hljs-keyword">while</span>(l != r) &#123;<br>        <span class="hljs-keyword">while</span>(p[r] &gt;= temp &amp;&amp; l &lt; r) r--;<br>        <span class="hljs-keyword">while</span>(p[l] &lt;= temp &amp;&amp; l &lt; r) l++;<br>        <span class="hljs-keyword">if</span>(l &lt; r) &#123;<br>            <span class="hljs-type">int</span> t = p[l];<br>            p[l] = p[r];<br>            p[r] = t;<br>        &#125;<br>    &#125;<br>    p[left] = p[l];<br>    p[l] = temp;<br>    <span class="hljs-built_in">quicksort</span>(p, left, l - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quicksort</span>(p, l + <span class="hljs-number">1</span>, right);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        n = (n &lt;&lt; <span class="hljs-number">1</span>) + (n &lt;&lt; <span class="hljs-number">3</span>) + (ch &amp; <span class="hljs-number">15</span>);<br>        ch = <span class="hljs-built_in">getchar</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> next;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> w;<br>&#125; edge[<span class="hljs-number">2</span> * <span class="hljs-number">50001</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>    edge[cnt].w = w;<br>    edge[cnt].to = v;<br>    edge[cnt].next = head[u];<br>    head[u] = cnt++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> top)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(top &lt; f[<span class="hljs-number">1</span>] || top &lt; f[n]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        dis[i] = inf;<br>        book[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    dis[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, cmp&gt; pq; <span class="hljs-comment">//用堆记录dis里面未松弛的点里面的最小值的点</span><br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        t = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(book[t] || top &lt; f[t]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//如果已经松弛或者当前点收费大于top时</span><br>        book[t] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[t]; i; i = edge[i].next) &#123; <span class="hljs-comment">//边的遍历，对dis松弛.</span><br>            <span class="hljs-keyword">if</span>(f[edge[i].to] &lt;= top &amp;&amp; !book[edge[i].to] &amp;&amp; dis[edge[i].to] &gt; dis[t] + edge[i].w) &#123;<br>                dis[edge[i].to] = dis[t] + edge[i].w;<br>                pq.<span class="hljs-built_in">push</span>(edge[i].to);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dis[n] &lt;= b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    m = <span class="hljs-built_in">read</span>();<br>    b = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-type">int</span> c[MAXn] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        f[i] = <span class="hljs-built_in">read</span>();<br>        c[i] = f[i];<br>    &#125;<br>    <span class="hljs-type">int</span> u, v, w;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        u = <span class="hljs-built_in">read</span>();<br>        v = <span class="hljs-built_in">read</span>();<br>        w = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">add</span>(u, v, w);<br>        <span class="hljs-built_in">add</span>(v, u, w);<br>    &#125;<br>    <span class="hljs-built_in">quicksort</span>(c, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = n, mid;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">check</span>(c[n])) &#123; <span class="hljs-comment">//判断是否有到达终点的路径</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AFK\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = c[n];<br>    <span class="hljs-keyword">while</span>(l &lt;= r) &#123; <span class="hljs-comment">//对点的费用按大小进行二分</span><br>        mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(c[mid])) &#123;<br>            r = mid - <span class="hljs-number">1</span>;<br>            ans = c[mid];<br>        &#125; <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模板</tag>
      
      <tag>dfs</tag>
      
      <tag>bfs</tag>
      
      <tag>并查集</tag>
      
      <tag>单源最短路径</tag>
      
      <tag>dijkstra</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01迷宫</title>
    <link href="/2019/09/27/01%E8%BF%B7%E5%AE%AB/"/>
    <url>/2019/09/27/01%E8%BF%B7%E5%AE%AB/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><p><em><strong>01迷宫</strong></em></p><p><a href="https://www.luogu.org/problem/P1141">题目链接(洛谷)</a></p><p>这题主要是理解题目意思，我一开始以为这题描述的是求能走的最长路径，后来wa了找不出问题，看了题解才知道原来不是求最长路径，而是求从某点能到达的所有的点的总数（包括自己）。理解了题意就容易了，我用的方法是先dfs+染色，再根据输入的位置来输出结果。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-type">int</span> a[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>], book[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>], f[<span class="hljs-number">1000001</span>], n, m; <span class="hljs-comment">//数组a保存地图，数组book记录染色情况，数组f记录某个颜色总大小</span><br><span class="hljs-type">int</span> next[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//前进的方向</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-comment">//快读</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch != <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; ch != <span class="hljs-string">&#x27;0&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> ch &amp; <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> aa, <span class="hljs-type">int</span> bb, <span class="hljs-type">int</span> color)</span> <span class="hljs-comment">//aa和bb为位置，color为当前染色的颜色</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tx, ty;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        tx = aa + next[i][<span class="hljs-number">0</span>];<br>        ty = bb + next[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(tx &lt; <span class="hljs-number">1</span> || ty &lt; <span class="hljs-number">1</span> || tx &gt; n || ty &gt; n || book[tx][ty] || a[tx][ty] == a[aa][bb]) <span class="hljs-keyword">continue</span>;<br>        f[color]++;<br>        book[tx][ty] = color;<br>        <span class="hljs-built_in">dfs</span>(tx, ty, color);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            a[i][j] = <span class="hljs-built_in">read</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">1</span>; <span class="hljs-comment">//颜色</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span>(!book[i][j]) &#123;<span class="hljs-comment">//当前点未经过染色</span><br>                f[c] = <span class="hljs-number">1</span>; <span class="hljs-comment">//把当前点也记录进去</span><br>                book[i][j] = c; <span class="hljs-comment">//开始染色</span><br>                <span class="hljs-built_in">dfs</span>(i, j, c++);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123; <span class="hljs-comment">//读入点的坐标</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, f[book[x][y]]); <span class="hljs-comment">//输出当前颜色占据的总大小，即当前点能到达的所有的点的数目</span><br>        <span class="hljs-keyword">if</span>(i != m) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂和矩阵的快速幂</title>
    <link href="/2019/09/21/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%92%8C%E7%9F%A9%E9%98%B5%E7%9A%84%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2019/09/21/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%92%8C%E7%9F%A9%E9%98%B5%E7%9A%84%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><h3 id="快速幂和矩阵的快速幂"><a href="#快速幂和矩阵的快速幂" class="headerlink" title="快速幂和矩阵的快速幂"></a>快速幂和矩阵的快速幂</h3><p>求a<sup>n</sup>的值，可以一个一个乘起来，也可以转化为其他多个数想乘，例如a<sup>n</sup>&#x3D;a<sup>n&#x2F;2</sup>* a<sup>n&#x2F;2</sup>&#x3D;a<sup>n&#x2F;3</sup>* a<sup>n&#x2F;3</sup>* a<sup>n&#x2F;3</sup>&#x3D;…，当n的值非常大的时候，这两种求法效率明显不够高，所以就有大佬想出了快速幂的算法，快速幂算法的主要代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<span class="hljs-comment">//res为记录结果的变量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">while</span>(n)&#123;<br><span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) res*=a;<br>n&gt;&gt;=<span class="hljs-number">1</span>;<br>a*=a;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果看代码无法理解（反正我开始直接看代码是没理解），则可以结合例子看代码：</p><blockquote><p>2<sup>76</sup>&#x3D;2<sup>01001100B(2进制)</sup>&#x3D;2<sup>100B</sup>* 2<sup>1000B</sup>* 2<sup>1000000B</sup>&#x3D;2<sup>4</sup>* 2<sup>8</sup> * 2<sup>64</sup></p></blockquote><p>而矩阵的快速幂算法则差不多是一样的，下面为题目贴图和代码：</p><blockquote><p><strong>方阵的阶乘</strong></p><p><strong>描述</strong></p><p>给定一个N阶方阵A，输出A的M次幂对10000求余的值（M是非负整数）</p><p><strong>输入</strong></p><p>第一行是一个正整数N、M（1&lt;&#x3D;N&lt;&#x3D;50, 0&lt;&#x3D;M&lt;&#x3D;7.5e18），表示方阵A的阶数和要求的幂数</p><p>接下来N行，每行N个绝对值不超过10的非负整数，描述方阵A的值</p><p><strong>输出</strong></p><p>输出共N行，每行N个整数，表示A的M次幂所对应的方阵对10000求余数。相邻的数之间用一个空格隔开</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-type">int</span> a[<span class="hljs-number">51</span>][<span class="hljs-number">51</span>], b[<span class="hljs-number">51</span>][<span class="hljs-number">51</span>]; <span class="hljs-comment">//a为当前输入的矩阵，b为记录结果的矩阵</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cheng</span><span class="hljs-params">(<span class="hljs-type">int</span> x[][<span class="hljs-number">51</span>], <span class="hljs-type">int</span> y[][<span class="hljs-number">51</span>])</span> <span class="hljs-comment">//x*=y(x和y为矩阵)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, z[<span class="hljs-number">51</span>][<span class="hljs-number">51</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>                sum += x[i][k] * y[k][j];<br>            &#125;<br>            z[i][j] = sum % <span class="hljs-number">10000</span>;<br>            sum = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            x[i][j] = z[i][j];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mi</span><span class="hljs-params">(<span class="hljs-type">int</span> x[][<span class="hljs-number">51</span>], <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span>(i == j) b[i][j] = <span class="hljs-number">1</span>; <span class="hljs-comment">//注意记录结果的数组初始值设置</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(m) &#123; <span class="hljs-comment">//主要代码</span><br>        <span class="hljs-keyword">if</span>(m &amp; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">cheng</span>(b, x);<br>        &#125;<br>        m &gt;&gt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">cheng</span>(x, x);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %lld&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">mi</span>(a, m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, b[i][j]);<br>            <span class="hljs-keyword">if</span>(j != n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i != n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速幂</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>To Fill or Not to Fill</title>
    <link href="/2019/09/14/To-Fill-or-Not-to-Fill/"/>
    <url>/2019/09/14/To-Fill-or-Not-to-Fill/</url>
    
    <content type="html"><![CDATA[<p><strong><span id="more"></span></strong></p><p><em><strong>题目：To Fill or Not to Fill&#96;</strong></em></p><p><a href="https://www.nowcoder.com/questionTerminal/f7eba38f7cd24c45982831e0f38518f9">传送门</a></p><p>这题主要是贪心，然后就是细节了，首先，输入的数字除了N以外都要用double（不能用float，不然有大的数据会通不过），具体思路是：1.当加油站之间的距离或与终点的距离大于满油时能行驶的最大距离时，要输出最大距离。2.在加油站的一定距离以内，第一个价格比当前加油站价格低的加油站为下一个需要直接到达的加油站。3.若在加油站以内没有比当前加油站价格低的加油站，则加满油后直接去最价格相对最低的加油站。4.若当前加油站能直接到达终点，且范围内没有价格更低的加油站时，直接到达终点（即使是最后一个加油站也是如此判断）。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> N, cur, minn;<br><span class="hljs-type">double</span> Cmax, D, Davg, oil = <span class="hljs-number">0.0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ss</span> &#123;<br>    <span class="hljs-type">double</span> m;<br>    <span class="hljs-type">double</span> p;<br>&#125; qq[<span class="hljs-number">510</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(ss a, ss b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.p &lt; b.p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    minn = cur;<br>    <span class="hljs-type">double</span> min = inf;<br>    <span class="hljs-keyword">if</span>(qq[cur + <span class="hljs-number">1</span>].p - qq[cur].p &gt; Cmax * Davg) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = cur + <span class="hljs-number">1</span>; qq[i].p - qq[cur].p &lt;= Cmax * Davg &amp;&amp; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">if</span>(qq[i].m &lt; qq[cur].m) &#123;<br>            minn = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(minn == cur) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = cur + <span class="hljs-number">1</span>; qq[j].p - qq[cur].p &lt;= Cmax * Davg &amp;&amp; j &lt; N; j++) &#123;<br>            <span class="hljs-keyword">if</span>(qq[j].m &lt; min) &#123;<br>                min = qq[j].m;<br>                minn = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> minn;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf %lf %lf %d&quot;</span>, &amp;Cmax, &amp;D, &amp;Davg, &amp;N);<br>    cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf %lf&quot;</span>, &amp;qq[i].m, &amp;qq[i].p);<br>    &#125;<br>    qq[N].p = D;<br>    <span class="hljs-comment">//printf(&quot;%d\n&quot;,qq[0].p);</span><br>    <span class="hljs-built_in">stable_sort</span>(qq, qq + N, cmp);<br>    <span class="hljs-comment">//printf(&quot;%d\n&quot;,qq[0].p);</span><br>    <span class="hljs-keyword">if</span>(qq[<span class="hljs-number">0</span>].p != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The maximum travel distance = 0.00&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">double</span> maxm = <span class="hljs-number">0.0</span>, maxp = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> r;<br><br>    <span class="hljs-type">bool</span> flag = <span class="hljs-number">1</span>;<br>    cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(flag) &#123;<br>        r = <span class="hljs-built_in">find</span>();<br>        <span class="hljs-comment">//printf(&quot;%d\n&quot;,r);</span><br>        <span class="hljs-comment">//printf(&quot;--%d\n&quot;,cur);</span><br>        <span class="hljs-keyword">if</span>(r == <span class="hljs-number">-1</span>) &#123;<br>            maxp = qq[cur].p + Cmax * Davg;<br>            flag = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r == cur) &#123;<br>            <span class="hljs-keyword">if</span>(qq[cur].p + Cmax * Davg &gt;= D) &#123;<br>                maxm += qq[cur].m * ((D - qq[cur].p) / Davg - oil);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            maxm += (Cmax - oil) * qq[cur].m;<br>            oil = Cmax - (qq[minn].p - qq[cur].p) / Davg;<br>            cur = minn;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            maxm += ((qq[r].p - qq[cur].p) / Davg - oil) * qq[cur].m;<br>            oil = <span class="hljs-number">0.0</span>;<br>            cur = r;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The maximum travel distance = %.2lf&quot;</span>, maxp);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf&quot;</span>, maxm);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
